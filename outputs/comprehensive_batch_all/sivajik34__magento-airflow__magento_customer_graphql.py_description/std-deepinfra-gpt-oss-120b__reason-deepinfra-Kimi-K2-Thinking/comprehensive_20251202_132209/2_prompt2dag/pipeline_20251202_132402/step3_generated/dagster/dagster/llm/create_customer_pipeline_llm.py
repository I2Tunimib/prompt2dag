# Generated by Dagster code generator
# Date: 2024-06-12
# Pipeline: create_customer_pipeline
# Description: No description provided.
# Executor: in_process_executor
# Resources: magento_graphql_api (Magento GraphQL API)

from typing import Any, Dict

from dagster import (
    op,
    job,
    In,
    Out,
    RetryPolicy,
    ResourceDefinition,
    fs_io_manager,
    in_process_executor,
    ConfigurableResource,
)


class MagentoGraphQLAPI(ConfigurableResource):
    """Resource for interacting with the Magento GraphQL API.

    This is a placeholder implementation. Replace the ``execute_query`` method with
    actual logic to call your Magento endpoint.
    """

    endpoint: str
    auth_token: str

    def execute_query(self, query: str, variables: Dict[str, Any] | None = None) -> Dict[str, Any]:
        """Execute a GraphQL query against the Magento endpoint.

        Args:
            query: The GraphQL query string.
            variables: Optional variables for the query.

        Returns:
            The parsed JSON response from Magento.
        """
        # Placeholder implementation â€“ in production replace with real HTTP request.
        raise NotImplementedError(
            "MagentoGraphQLAPI.execute_query must be implemented to call the Magento endpoint."
        )


magento_graphql_api_resource = ResourceDefinition.resource(
    resource_fn=lambda init_context: MagentoGraphQLAPI(
        endpoint=init_context.resource_config["endpoint"],
        auth_token=init_context.resource_config["auth_token"],
    ),
    config_schema={"endpoint": str, "auth_token": str},
    description="Magento GraphQL API client",
)


@op(
    out=Out(dagster_type=dict, description="Created customer data, e.g., {'id': 123}"),
    retry_policy=RetryPolicy(max_retries=1),
    description="Creates a new customer in Magento via GraphQL.",
)
def create_customer(context) -> dict:
    """Create a new customer using the Magento GraphQL API.

    Returns:
        A dictionary containing at least the newly created customer's ID.
    """
    query = """
    mutation CreateCustomer($input: CustomerInput!) {
        createCustomer(input: $input) {
            customer {
                id
                email
            }
        }
    }
    """
    variables = {
        "input": {
            "email": "new_customer@example.com",
            "firstname": "John",
            "lastname": "Doe",
            # Add additional required fields here.
        }
    }

    api: MagentoGraphQLAPI = context.resources.magento_graphql_api
    try:
        result = api.execute_query(query, variables)
        customer = result["data"]["createCustomer"]["customer"]
        context.log.info(f"Created customer with ID {customer['id']}")
        return {"id": customer["id"], "email": customer["email"]}
    except Exception as exc:
        context.log.error(f"Failed to create customer: {exc}")
        raise


@op(
    ins={"customer": In(dagster_type=dict)},
    out=Out(dagster_type=str, description="Customer authentication token"),
    retry_policy=RetryPolicy(max_retries=1),
    description="Generates a JWT token for the newly created customer.",
)
def generate_customer_token(context, customer: dict) -> str:
    """Generate a Magento customer token using the customer's credentials.

    Args:
        customer: Dictionary containing at least the customer's email.

    Returns:
        A JWT token string for authenticating subsequent requests.
    """
    query = """
    mutation GenerateToken($email: String!, $password: String!) {
        generateCustomerToken(email: $email, password: $password) {
            token
        }
    }
    """
    # In a real scenario, you would have the password used during creation.
    variables = {
        "email": customer["email"],
        "password": "examplePassword123",  # Replace with actual password handling.
    }

    api: MagentoGraphQLAPI = context.resources.magento_graphql_api
    try:
        result = api.execute_query(query, variables)
        token = result["data"]["generateCustomerToken"]["token"]
        context.log.info(f"Generated token for customer ID {customer['id']}")
        return token
    except Exception as exc:
        context.log.error(f"Failed to generate token for customer {customer['id']}: {exc}")
        raise


@op(
    ins={"token": In(dagster_type=str)},
    out=Out(dagster_type=dict, description="Customer information retrieved from Magento"),
    retry_policy=RetryPolicy(max_retries=1),
    description="Retrieves detailed information about a customer using their token.",
)
def get_customer_info(context, token: str) -> dict:
    """Fetch detailed customer information using the authentication token.

    Args:
        token: JWT token for the customer.

    Returns:
        A dictionary with the customer's profile data.
    """
    query = """
    query GetCustomer {
        customer {
            id
            email
            firstname
            lastname
            # Add additional fields as needed.
        }
    }
    """
    # The token is typically sent via HTTP headers; this placeholder assumes the
    # resource knows how to include it.
    api: MagentoGraphQLAPI = context.resources.magento_graphql_api
    try:
        result = api.execute_query(query)
        customer_info = result["data"]["customer"]
        context.log.info(f"Retrieved info for customer ID {customer_info['id']}")
        return customer_info
    except Exception as exc:
        context.log.error(f"Failed to retrieve customer info with token: {exc}")
        raise


@job(
    executor_def=in_process_executor,
    resource_defs={
        "magento_graphql_api": magento_graphql_api_resource,
        "io_manager": fs_io_manager,
    },
    description="No description provided.",
)
def create_customer_pipeline():
    """Dagster job that creates a Magento customer, generates a token, and fetches the customer's info.

    The execution order is:
        1. create_customer
        2. generate_customer_token (depends on create_customer)
        3. get_customer_info (depends on generate_customer_token)
    """
    customer = create_customer()
    token = generate_customer_token(customer)
    get_customer_info(token)
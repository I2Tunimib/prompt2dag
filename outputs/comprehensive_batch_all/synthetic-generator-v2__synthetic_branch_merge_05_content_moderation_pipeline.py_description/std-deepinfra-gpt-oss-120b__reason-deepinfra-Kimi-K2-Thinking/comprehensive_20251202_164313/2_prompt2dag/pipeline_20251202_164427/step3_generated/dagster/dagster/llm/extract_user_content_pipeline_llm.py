# Generated by Dagster Code Generator
# Date: 2024-06-28
# Pipeline: extract_user_content_pipeline
# Description: Content Moderation Pipeline
# Pattern: fanout_fanin
# Dagster version: 1.5.0

from datetime import datetime
from typing import Any, Dict, List

import dagster
from dagster import (
    In,
    Out,
    RetryPolicy,
    ResourceDefinition,
    io_manager,
    job,
    op,
    schedule,
    in_process_executor,
    ConfigurableResource,
    InitResourceContext,
    Output,
    Nothing,
)

# ----------------------------------------------------------------------
# Resource Definitions
# ----------------------------------------------------------------------


class ContentManagementAPI(ConfigurableResource):
    """Placeholder for the platform's content management system API."""

    api_key: str = ""

    def fetch_user_content(self) -> List[Dict[str, Any]]:
        """Fetch raw user‑generated content."""
        # In a real implementation this would call an external service.
        return [
            {"id": 1, "text": "I love this product!"},
            {"id": 2, "text": "This is terrible, you suck!"},
        ]


class PublishingAPI(ConfigurableResource):
    """Placeholder for the platform's publishing system API."""

    api_key: str = ""

    def publish(self, content: List[Dict[str, Any]]) -> None:
        """Publish safe content."""
        # Real implementation would POST to a publishing endpoint.
        for item in content:
            print(f"Publishing content ID {item['id']}: {item['text']}")


class AuditLoggingAPI(ConfigurableResource):
    """Placeholder for the audit logging system."""

    api_key: str = ""

    def log(self, entry: Dict[str, Any]) -> None:
        """Write an audit log entry."""
        print(f"Audit log entry: {entry}")


class EmailSMTPService(ConfigurableResource):
    """Placeholder for an email notification service."""

    smtp_server: str = "localhost"
    smtp_port: int = 25

    def send_email(self, subject: str, body: str, recipients: List[str]) -> None:
        """Send an email notification."""
        print(f"Sending email to {recipients}: {subject}")


@io_manager
def fs_io_manager(init_context: InitResourceContext):
    """Simple CSV‑based IO manager that writes/reads from the local filesystem."""

    class CSVIOManager:
        def handle_output(self, context, obj):
            import csv
            import os

            path = os.path.join(context.resource_config["base_dir"], f"{context.step_key}.csv")
            os.makedirs(os.path.dirname(path), exist_ok=True)
            with open(path, "w", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, fieldnames=obj[0].keys())
                writer.writeheader()
                writer.writerows(obj)
            context.log.info(f"Wrote CSV to {path}")

        def load_input(self, context):
            import csv
            import os

            path = os.path.join(context.resource_config["base_dir"], f"{context.upstream_output.step_key}.csv")
            with open(path, newline="", encoding="utf-8") as f:
                reader = csv.DictReader(f)
                data = [row for row in reader]
            context.log.info(f"Read CSV from {path}")
            return data

    return CSVIOManager()


# ----------------------------------------------------------------------
# Op Definitions
# ----------------------------------------------------------------------


@op(
    name="Extract User Content",
    out=Out(List[Dict[str, Any]], description="Raw user content"),
    retry_policy=RetryPolicy(max_retries=2),
    description="Extract raw user‑generated content from the content management system.",
)
def extract_user_content(context, content_mgmt: ContentManagementAPI) -> List[Dict[str, Any]]:
    """Fetch user content via the ContentManagementAPI resource."""
    content = content_mgmt.fetch_user_content()
    context.log.info(f"Extracted {len(content)} content items.")
    return content


@op(
    name="Evaluate Toxicity",
    ins={"raw_content": In(List[Dict[str, Any]])},
    out=Out(
        List[Dict[str, Any]],
        description="Content annotated with toxicity scores",
    ),
    retry_policy=RetryPolicy(max_retries=2),
    description="Score each piece of content for toxicity.",
)
def evaluate_toxicity(context, raw_content: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Simple heuristic toxicity evaluation."""
    def is_toxic(text: str) -> bool:
        toxic_keywords = {"terrible", "suck", "hate", "bad"}
        return any(word in text.lower() for word in toxic_keywords)

    annotated = []
    for item in raw_content:
        toxic = is_toxic(item["text"])
        annotated.append({**item, "toxic": toxic})
        context.log.info(f"Content ID {item['id']} toxic={toxic}")

    return annotated


@op(
    name="Publish Safe Content",
    ins={"annotated_content": In(List[Dict[str, Any]])},
    out=Out(Nothing),
    retry_policy=RetryPolicy(max_retries=2),
    description="Publish content that is not flagged as toxic.",
)
def publish_content(
    context,
    annotated_content: List[Dict[str, Any]],
    publishing: PublishingAPI,
) -> Nothing:
    """Publish only non‑toxic content."""
    safe_content = [c for c in annotated_content if not c["toxic"]]
    if safe_content:
        publishing.publish(safe_content)
        context.log.info(f"Published {len(safe_content)} safe items.")
    else:
        context.log.info("No safe content to publish.")
    return Nothing


@op(
    name="Remove and Flag Toxic Content",
    ins={"annotated_content": In(List[Dict[str, Any]])},
    out=Out(List[Dict[str, Any]], description="Toxic content that was removed/flagged"),
    retry_policy=RetryPolicy(max_retries=2),
    description="Remove toxic content and flag it for review.",
)
def remove_and_flag_content(
    context,
    annotated_content: List[Dict[str, Any]],
    email_service: EmailSMTPService,
) -> List[Dict[str, Any]]:
    """Identify toxic items, simulate removal, and send a notification."""
    toxic_items = [c for c in annotated_content if c["toxic"]]
    if toxic_items:
        ids = [c["id"] for c in toxic_items]
        context.log.info(f"Removing toxic content IDs: {ids}")
        # Simulate email notification
        subject = "Toxic Content Detected"
        body = f"The following content IDs were removed: {ids}"
        email_service.send_email(subject, body, recipients=["moderation@example.com"])
    else:
        context.log.info("No toxic content found.")
    return toxic_items


@op(
    name="Create Audit Log",
    ins={
        "removed_content": In(List[Dict[str, Any]]),
        "published_content": In(Nothing),
    },
    out=Out(Nothing),
    retry_policy=RetryPolicy(max_retries=2),
    description="Create an audit log entry for moderation actions.",
)
def audit_log(
    context,
    removed_content: List[Dict[str, Any]],
    audit_logger: AuditLoggingAPI,
) -> Nothing:
    """Write an audit entry summarising moderation actions."""
    entry = {
        "timestamp": datetime.utcnow().isoformat(),
        "removed_content_ids": [c["id"] for c in removed_content],
        "action": "moderation",
    }
    audit_logger.log(entry)
    context.log.info("Audit log entry created.")
    return Nothing


# ----------------------------------------------------------------------
# Job Definition
# ----------------------------------------------------------------------


@job(
    name="extract_user_content_pipeline",
    description="Content Moderation Pipeline",
    executor_def=in_process_executor,
    resource_defs={
        "content_mgmt": ContentManagementAPI(),
        "publishing": PublishingAPI(),
        "audit_logger": AuditLoggingAPI(),
        "email_service": EmailSMTPService(),
        "io_manager": fs_io_manager.configured({"base_dir": "./data"}),
    },
    # The default IO manager is set via the resource key "io_manager"
)
def extract_user_content_pipeline():
    """Orchestrates content extraction, toxicity evaluation, publishing, removal, and auditing."""
    raw = extract_user_content(content_mgmt=dagster.ResourceDefinition.hardcoded_resource(ContentManagementAPI()))
    evaluated = evaluate_toxicity(raw_content=raw)

    # Fan‑out
    publish = publish_content(annotated_content=evaluated, publishing=dagster.ResourceDefinition.hardcoded_resource(PublishingAPI()))
    removed = remove_and_flag_content(annotated_content=evaluated, email_service=dagster.ResourceDefinition.hardcoded_resource(EmailSMTPService()))

    # Fan‑in
    audit_log(removed_content=removed, published_content=publish)


# ----------------------------------------------------------------------
# Schedule Definition
# ----------------------------------------------------------------------


@schedule(
    cron_schedule="@daily",
    job=extract_user_content_pipeline,
    execution_timezone="UTC",
    name="extract_user_content_daily_schedule",
    description="Daily execution of the content moderation pipeline.",
    default_status=dagster.ScheduleStatus.RUNNING,
    tags={"catchup": "false"},
)
def daily_content_moderation_schedule():
    """Schedule that triggers the content moderation pipeline once per day at midnight UTC."""
    return {}


# ----------------------------------------------------------------------
# End of file
# ----------------------------------------------------------------------
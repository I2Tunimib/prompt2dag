# Generated by Prefect Pipeline Generator
# Timestamp: 2024-06-28 12:00:00 UTC
# Prefect version: 2.14.0
# Flow name: run_ctas_pipeline

import os
import json
import logging
from datetime import datetime
from typing import Any, Dict

import prefect
from prefect import flow, task, get_run_logger
from prefect.task_runners import SequentialTaskRunner
from prefect.blocks.system import Secret

# Optional: Snowflake connector and Slack SDK imports
try:
    import snowflake.connector
except ImportError:  # pragma: no cover
    snowflake = None

try:
    from slack_sdk import WebClient
    from slack_sdk.errors import SlackApiError
except ImportError:  # pragma: no cover
    WebClient = None
    SlackApiError = Exception


@task(retries=0, name="Create Analytics Table via CTAS")
def run_ctas(snowflake_secret_name: str = "snowflake_conn") -> None:
    """
    Execute a CREATE TABLE AS SELECT (CTAS) statement in Snowflake to build
    an analytics table.

    The Snowflake connection parameters are stored in a Prefect Secret block
    named ``snowflake_conn``. The secret should contain a JSON string with the
    keys required by ``snowflake.connector.connect`` (e.g. user, password,
    account, warehouse, database, schema).

    Args:
        snowflake_secret_name: Name of the Prefect Secret block containing the
            Snowflake credentials.

    Raises:
        RuntimeError: If the Snowflake connector is not installed or the CTAS
            statement fails.
    """
    logger = get_run_logger()
    if snowflake is None:
        raise RuntimeError("snowflake-connector-python is not installed.")

    # Retrieve Snowflake credentials from Prefect Secret block
    secret_block = Secret.load(snowflake_secret_name)
    credentials_json = secret_block.get()
    try:
        credentials: Dict[str, Any] = json.loads(credentials_json)
    except json.JSONDecodeError as exc:
        raise RuntimeError("Snowflake secret must be a valid JSON string.") from exc

    logger.info("Connecting to Snowflake...")
    ctx = snowflake.connector.connect(**credentials)
    cs = ctx.cursor()
    try:
        # Example CTAS statement â€“ replace with your actual query
        ctas_sql = """
        CREATE OR REPLACE TABLE analytics.my_analytics_table AS
        SELECT
            *
        FROM source_schema.source_table
        WHERE event_date = CURRENT_DATE()
        """
        logger.info("Executing CTAS statement.")
        cs.execute(ctas_sql)
        logger.info("CTAS completed successfully.")
    finally:
        cs.close()
        ctx.close()


@task(retries=0, name="Slack Failure Notification")
def slack_failure_alert(
    error_message: str,
    slack_secret_name: str = "slack_api",
    channel: str = "#alerts",
) -> None:
    """
    Send a failure notification to Slack.

    The Slack Bot token is stored in a Prefect Secret block named
    ``slack_api``. The secret should contain the raw token string.

    Args:
        error_message: The error message to include in the Slack notification.
        slack_secret_name: Name of the Prefect Secret block containing the Slack token.
        channel: Slack channel (or user) where the alert should be posted.

    Raises:
        RuntimeError: If the Slack SDK is not installed or the message fails to send.
    """
    logger = get_run_logger()
    if WebClient is None:
        raise RuntimeError("slack-sdk is not installed.")

    # Retrieve Slack token from Prefect Secret block
    secret_block = Secret.load(slack_secret_name)
    token = secret_block.get().strip()

    client = WebClient(token=token)

    message = (
        f":warning: *Prefect Flow Failure*\n"
        f"*Flow:* `{prefect.context.get('flow_name', 'run_ctas_pipeline')}`\n"
        f"*Run ID:* `{prefect.context.get('flow_run_id', 'unknown')}`\n"
        f"*Timestamp:* `{datetime.utcnow().isoformat()}Z`\n"
        f"*Error:* ```{error_message}```"
    )

    try:
        logger.info("Sending Slack failure alert to %s.", channel)
        response = client.chat_postMessage(channel=channel, text=message)
        logger.debug("Slack response: %s", response)
    except SlackApiError as exc:
        raise RuntimeError(f"Failed to send Slack alert: {exc.response['error']}") from exc


@flow(
    name="run_ctas_pipeline",
    task_runner=SequentialTaskRunner(),
)
def run_ctas_pipeline() -> None:
    """
    Prefect flow that creates an analytics table via a Snowflake CTAS statement.
    If the CTAS operation fails, a Slack notification is sent.

    The flow follows a sequential execution pattern and does not include any
    automatic retries for its tasks.
    """
    logger = get_run_logger()
    try:
        run_ctas()
        logger.info("run_ctas task completed without errors.")
    except Exception as exc:
        error_msg = str(exc)
        logger.error("run_ctas task failed: %s", error_msg)
        # Trigger Slack alert on failure
        slack_failure_alert(error_message=error_msg)


if __name__ == "__main__":
    # Execute the flow locally. In production, this flow would be deployed
    # via a Prefect deployment with the configuration specified in the
    # orchestrator-specific configuration block.
    run_ctas_pipeline()
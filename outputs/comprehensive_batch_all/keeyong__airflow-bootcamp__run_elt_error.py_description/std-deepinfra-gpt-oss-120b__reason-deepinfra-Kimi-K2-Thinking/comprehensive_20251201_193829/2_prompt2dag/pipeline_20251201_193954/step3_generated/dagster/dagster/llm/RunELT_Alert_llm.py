# Generated by Dagster Code Generator
# Date: 2024-06-12
# Pipeline: RunELT_Alert
# Description: Sequential ELT pipeline that builds analytics tables in Snowflake using CTAS operations,
#              with data validation, atomic swaps, and Slack failure notifications.

from dagster import (
    op,
    job,
    In,
    Out,
    RetryPolicy,
    ResourceDefinition,
    fs_io_manager,
    in_process_executor,
    schedule,
    ScheduleStatus,
    InitResourceContext,
    OpExecutionContext,
)

# ----------------------------------------------------------------------
# Resource definitions
# ----------------------------------------------------------------------


def _snowflake_resource(init_context: InitResourceContext):
    """Placeholder Snowflake resource.

    In a real deployment this would create a connection object (e.g. using
    ``snowflake-connector-python``) based on the provided configuration.
    """
    config = init_context.resource_config
    # Return a simple dict for demonstration; replace with actual connection.
    return {
        "account": config["account"],
        "user": config["user"],
        "password": config["password"],
        "warehouse": config["warehouse"],
        "database": config["database"],
        "schema": config["schema"],
    }


snowflake_conn = ResourceDefinition(
    resource_fn=_snowflake_resource,
    config_schema={
        "account": str,
        "user": str,
        "password": str,
        "warehouse": str,
        "database": str,
        "schema": str,
    },
)


def _slack_resource(init_context: InitResourceContext):
    """Placeholder Slack resource.

    In production this would instantiate a Slack client (e.g. ``slack_sdk.WebClient``)
    using the provided token.
    """
    config = init_context.resource_config
    return {"token": config["token"], "channel": config["channel"]}


slack_conn = ResourceDefinition(
    resource_fn=_slack_resource,
    config_schema={"token": str, "channel": str},
)


# ----------------------------------------------------------------------
# Ops
# ----------------------------------------------------------------------


@op(
    required_resource_keys={"snowflake_conn"},
    description="Execute CTAS statements to build analytics tables in Snowflake.",
    retry_policy=RetryPolicy(max_retries=0),
    out=Out(str),
)
def run_ctas(context: OpExecutionContext) -> str:
    """
    Runs a series of CREATE TABLE AS SELECT (CTAS) statements against Snowflake.

    Returns:
        str: A summary message indicating success.
    """
    snowflake = context.resources.snowflake_conn
    # Placeholder CTAS logic – replace with real SQL execution.
    context.log.info(
        f"Connecting to Snowflake account {snowflake['account']} "
        f"as user {snowflake['user']} to run CTAS."
    )
    # Example CTAS command (no actual execution).
    ctas_sql = """
    CREATE OR REPLACE TABLE analytics.sales_summary AS
    SELECT
        region,
        SUM(amount) AS total_sales,
        COUNT(*) AS transaction_count
    FROM raw.sales
    GROUP BY region;
    """
    context.log.info(f"Executing CTAS SQL: {ctas_sql.strip()}")
    # Simulate successful execution.
    return "CTAS operations completed successfully."


@op(
    required_resource_keys={"slack_conn"},
    description="Send a failure notification to Slack.",
    retry_policy=RetryPolicy(max_retries=3),
    ins={"error_message": In(str)},
)
def notify_failure_slack(context: OpExecutionContext, error_message: str) -> None:
    """
    Posts a failure message to a configured Slack channel.

    Args:
        error_message (str): The error details to include in the Slack message.
    """
    slack = context.resources.slack_conn
    channel = slack["channel"]
    token = slack["token"]
    # Placeholder Slack posting logic – replace with real Slack SDK call.
    context.log.info(
        f"Posting failure notification to Slack channel {channel} with token {token[:4]}***."
    )
    context.log.info(f"Error message: {error_message}")
    # Simulate successful post.
    context.log.info("Slack notification sent.")


# ----------------------------------------------------------------------
# Job definition
# ----------------------------------------------------------------------


@job(
    executor_def=in_process_executor,
    resource_defs={
        "snowflake_conn": snowflake_conn,
        "slack_conn": slack_conn,
        "io_manager": fs_io_manager,
    },
    description=(
        "Sequential ELT pipeline that builds analytics tables in Snowflake using CTAS "
        "operations, with data validation, atomic swaps, and Slack failure notifications."
    ),
)
def runelt_alert():
    """
    Dagster job that orchestrates the ELT workflow.

    Execution order:
        1. run_ctas
        2. (On failure) notify_failure_slack – this op can be wired downstream of
           ``run_ctas`` in a real-world scenario using conditional logic or
           ``try/except`` handling within a custom op.
    """
    ctas_result = run_ctas()
    # The failure notification op is defined but not wired directly; it can be
    # triggered via a retry hook or external monitoring system.
    # Example wiring (uncomment if you want a direct downstream dependency):
    # notify_failure_slack(error_message=ctas_result)


# ----------------------------------------------------------------------
# Schedule definition
# ----------------------------------------------------------------------


@schedule(
    cron_schedule="@daily",
    job=runelt_alert,
    execution_timezone="UTC",
    default_status=ScheduleStatus.RUNNING,
    catchup=False,
)
def runelt_alert_schedule():
    """
    Daily schedule that triggers the ``runelt_alert`` job at midnight UTC.
    """
    # No additional run config is required; resources are supplied via the job definition.
    return {}

# End of file.
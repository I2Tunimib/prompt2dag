# Generated by Dagster Pipeline Generator
# Date: 2024-06-28
# Pipeline: start_backup_process_pipeline
# Description: No description provided.
# Executor: in_process_executor
# Dagster version: 1.5.0

from typing import Any, Dict

from dagster import (
    In,
    Out,
    RetryPolicy,
    op,
    job,
    fs_io_manager,
    ScheduleDefinition,
    DefaultScheduleStatus,
    Definitions,
    ConfigurableResource,
    ResourceDefinition,
    InitResourceContext,
    get_dagster_logger,
    InMemoryIOManager,
    in_process_executor,
)


# -------------------------------------------------------------------------
# Ops
# -------------------------------------------------------------------------

@op(
    name="start_backup_process",
    description="Initial step that triggers the backup workflow.",
    out=Out(dagster_type=Dict[str, Any]),
    retry_policy=RetryPolicy(max_retries=2),
)
def start_backup_process(context) -> Dict[str, Any]:
    """Kick‑off the backup process.

    Returns a dictionary that can be used by downstream ops for logging or
    correlation purposes.
    """
    logger = get_dagster_logger()
    logger.info("Starting backup process...")
    # Placeholder payload
    return {"run_id": context.run_id}


@op(
    name="date_check_task",
    description="Determine which backup strategy to use based on the current date.",
    ins={"start_payload": In(dagster_type=Dict[str, Any])},
    out=Out(dagster_type=str),
    retry_policy=RetryPolicy(max_retries=2),
)
def date_check_task(context, start_payload: Dict[str, Any]) -> str:
    """Inspect the date and decide between a full or incremental backup.

    For demonstration purposes we always return ``full``; replace with real
    logic as needed.
    """
    logger = get_dagster_logger()
    logger.info(f"Received start payload: {start_payload}")
    # Example decision logic (placeholder)
    decision = "full"
    logger.info(f"Backup strategy decided: {decision}")
    return decision


@op(
    name="full_backup_task",
    description="Perform a full backup of the target data.",
    ins={"strategy": In(dagster_type=str)},
    out=Out(dagster_type=bool),
    retry_policy=RetryPolicy(max_retries=2),
)
def full_backup_task(context, strategy: str) -> bool:
    """Execute a full backup.

    Returns ``True`` on success.
    """
    logger = get_dagster_logger()
    logger.info(f"Full backup triggered with strategy: {strategy}")
    # Insert real backup logic here
    success = True
    logger.info(f"Full backup completed: {success}")
    return success


@op(
    name="incremental_backup_task",
    description="Perform an incremental backup of the target data.",
    ins={"strategy": In(dagster_type=str)},
    out=Out(dagster_type=bool),
    retry_policy=RetryPolicy(max_retries=2),
)
def incremental_backup_task(context, strategy: str) -> bool:
    """Execute an incremental backup.

    Returns ``True`` on success.
    """
    logger = get_dagster_logger()
    logger.info(f"Incremental backup triggered with strategy: {strategy}")
    # Insert real incremental backup logic here
    success = True
    logger.info(f"Incremental backup completed: {success}")
    return success


@op(
    name="verify_backup_task",
    description="Validate the integrity of the performed backups.",
    ins={
        "full_success": In(dagster_type=bool),
        "incremental_success": In(dagster_type=bool),
    },
    out=Out(dagster_type=bool),
    retry_policy=RetryPolicy(max_retries=2),
)
def verify_backup_task(context, full_success: bool, incremental_success: bool) -> bool:
    """Verify that both backup types succeeded and are consistent.

    Returns ``True`` if verification passes.
    """
    logger = get_dagster_logger()
    logger.info(f"Full backup success flag: {full_success}")
    logger.info(f"Incremental backup success flag: {incremental_success}")

    # Simple verification placeholder
    verification_passed = full_success and incremental_success
    logger.info(f"Backup verification result: {verification_passed}")
    return verification_passed


@op(
    name="backup_complete",
    description="Final step signalling successful completion of the backup workflow.",
    ins={"verification": In(dagster_type=bool)},
    out=Out(dagster_type=str),
    retry_policy=RetryPolicy(max_retries=2),
)
def backup_complete(context, verification: bool) -> str:
    """Mark the backup process as complete.

    Returns a human‑readable status message.
    """
    logger = get_dagster_logger()
    if verification:
        status = "Backup workflow completed successfully."
    else:
        status = "Backup workflow completed with verification failures."
    logger.info(status)
    return status


# -------------------------------------------------------------------------
# Job definition
# -------------------------------------------------------------------------

@job(
    name="start_backup_process_pipeline",
    description="No description provided.",
    executor_def=in_process_executor,
    resource_defs={"io_manager": fs_io_manager},
)
def start_backup_process_pipeline():
    """Dagster job orchestrating a full/incremental backup workflow.

    The job follows a fan‑out/fan‑in pattern:
    1. Start the process.
    2. Determine backup strategy.
    3. Run both full and incremental backups in parallel.
    4. Verify both backups.
    5. Signal completion.
    """
    start_payload = start_backup_process()
    strategy = date_check_task(start_payload)

    # Fan‑out: both backup types run regardless of strategy (adjust as needed)
    full_success = full_backup_task(strategy)
    incremental_success = incremental_backup_task(strategy)

    verification = verify_backup_task(full_success, incremental_success)
    backup_complete(verification)


# -------------------------------------------------------------------------
# Schedule definition
# -------------------------------------------------------------------------

daily_backup_schedule = ScheduleDefinition(
    job=start_backup_process_pipeline,
    cron_schedule="@daily",  # Equivalent to "0 0 * * *"
    execution_timezone="UTC",
    default_status=DefaultScheduleStatus.RUNNING,
    description="Daily schedule for the backup pipeline.",
)


# -------------------------------------------------------------------------
# Definitions (entry point for Dagster UI / CLI)
# -------------------------------------------------------------------------

defs = Definitions(
    jobs=[start_backup_process_pipeline],
    schedules=[daily_backup_schedule],
    resources={"io_manager": fs_io_manager},
)
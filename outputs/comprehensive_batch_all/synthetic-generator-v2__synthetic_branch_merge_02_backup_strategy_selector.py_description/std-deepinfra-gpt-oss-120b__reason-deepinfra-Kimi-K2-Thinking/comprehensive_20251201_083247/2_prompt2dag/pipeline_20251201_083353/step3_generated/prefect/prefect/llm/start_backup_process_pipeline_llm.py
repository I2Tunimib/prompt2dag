# Generated by Prefect Pipeline Generator
# Date: 2024-06-28
# Pipeline: start_backup_process_pipeline
# Description: No description provided.
# Pattern: fanout_fanin
# Prefect version: 2.14.0

import subprocess
from typing import Any

from prefect import flow, task
from prefect.task_runners import SequentialTaskRunner


def _run_command(command: str) -> str:
    """
    Execute a shell command and return its stdout.

    Args:
        command: The command to execute.

    Returns:
        The standard output from the command.

    Raises:
        subprocess.CalledProcessError: If the command exits with a non-zero status.
    """
    result = subprocess.run(
        command,
        shell=True,
        check=True,
        capture_output=True,
        text=True,
    )
    return result.stdout.strip()


@task(retries=2, name="Start Backup Process")
def start_backup_process() -> str:
    """
    Initiates the backup process.

    Returns:
        A message indicating the start of the backup.
    """
    return _run_command("echo Starting backup process")


@task(retries=2, name="Determine Backup Strategy")
def determine_backup_strategy(start_msg: str) -> str:
    """
    Determines whether to perform a full or incremental backup.

    Args:
        start_msg: Message from the start_backup_process task.

    Returns:
        The chosen backup strategy.
    """
    # Placeholder logic; replace with real decision-making as needed.
    return _run_command("echo Determining backup strategy based on: '{}'".format(start_msg))


@task(retries=2, name="Full Backup")
def full_backup(strategy_msg: str) -> str:
    """
    Performs a full backup.

    Args:
        strategy_msg: Message from the determine_backup_strategy task.

    Returns:
        Result of the full backup operation.
    """
    return _run_command("echo Performing full backup (strategy: '{}')".format(strategy_msg))


@task(retries=2, name="Incremental Backup")
def incremental_backup(strategy_msg: str) -> str:
    """
    Performs an incremental backup.

    Args:
        strategy_msg: Message from the determine_backup_strategy task.

    Returns:
        Result of the incremental backup operation.
    """
    return _run_command("echo Performing incremental backup (strategy: '{}')".format(strategy_msg))


@task(retries=2, name="Verify Backup")
def verify_backup(full_msg: str, incremental_msg: str) -> str:
    """
    Verifies the integrity of the backup.

    Args:
        full_msg: Output from the full_backup task.
        incremental_msg: Output from the incremental_backup task.

    Returns:
        Verification result.
    """
    verification_cmd = (
        "echo Verifying backup using full backup output: '{}' and incremental backup output: '{}'"
        .format(full_msg, incremental_msg)
    )
    return _run_command(verification_cmd)


@task(retries=2, name="Backup Complete")
def backup_complete(verification_msg: str) -> str:
    """
    Marks the backup process as complete.

    Args:
        verification_msg: Result from the verify_backup task.

    Returns:
        Completion message.
    """
    return _run_command("echo Backup complete. Verification: '{}'".format(verification_msg))


@flow(
    name="start_backup_process_pipeline",
    task_runner=SequentialTaskRunner(),
)
def start_backup_process_pipeline() -> Any:
    """
    Orchestrates the backup workflow using a fan‑out/fan‑in pattern.

    Execution order:
        start_backup_process → determine_backup_strategy
        → [full_backup, incremental_backup] (parallel)
        → verify_backup → backup_complete
    """
    # Step 1: Start the backup process
    start_msg = start_backup_process()

    # Step 2: Determine which backup strategy to use
    strategy_msg = determine_backup_strategy(start_msg)

    # Step 3: Fan‑out – run full and incremental backups in parallel
    full_msg = full_backup.submit(strategy_msg)
    incremental_msg = incremental_backup.submit(strategy_msg)

    # Step 4: Fan‑in – verify after both backups complete
    verification_msg = verify_backup(full_msg.result(), incremental_msg.result())

    # Step 5: Mark the backup as complete
    completion_msg = backup_complete(verification_msg)

    return completion_msg


if __name__ == "__main__":
    # Running the flow directly (useful for local testing)
    result = start_backup_process_pipeline()
    print("Pipeline result:", result)
# Generated by Prefect Pipeline Generator
# Date: 2024-06-28
# Pipeline: Backup Strategy Selector
# Description: Selects a backup strategy (full or incremental) based on the day of week,
#              using a fanout-fanin pattern.

import logging
import subprocess
from datetime import datetime
from typing import Literal, Optional

from prefect import flow, task, get_run_logger
from prefect.task_runners import SequentialTaskRunner
from prefect.deployments import Deployment
from prefect.orion.schemas.schedules import CronSchedule

# -------------------------------------------------------------------------
# Task Definitions
# -------------------------------------------------------------------------

@task(retries=0, name="Start Backup Process")
def start_backup_process() -> None:
    """
    Initialize the backup process.
    This task could perform any necessary setup such as creating temp directories
    or initializing logging.
    """
    logger = get_run_logger()
    logger.info("Backup process started.")
    # Example placeholder for a real setup command
    subprocess.run(["echo", "Setup complete"], check=True)


@task(retries=2, name="Determine Backup Strategy")
def determine_backup_strategy() -> Literal["full", "incremental"]:
    """
    Determine which backup strategy to use based on the current UTC day of week.
    Returns:
        "full" if today is Monday, otherwise "incremental".
    """
    logger = get_run_logger()
    today = datetime.utcnow().strftime("%A")
    logger.info(f"Today (UTC) is {today}.")
    if today == "Monday":
        strategy = "full"
    else:
        strategy = "incremental"
    logger.info(f"Selected backup strategy: {strategy}.")
    return strategy


@task(retries=2, name="Perform Full Backup")
def perform_full_backup(strategy: Literal["full", "incremental"]) -> Optional[str]:
    """
    Execute a full backup if the selected strategy is 'full'.
    Args:
        strategy: The backup strategy determined earlier.
    Returns:
        Path to the full backup file if performed, otherwise None.
    """
    logger = get_run_logger()
    if strategy != "full":
        logger.info("Full backup skipped (strategy is incremental).")
        return None

    logger.info("Starting full backup...")
    try:
        # Placeholder command; replace with actual backup command
        result = subprocess.run(
            ["echo", "Performing full backup..."], capture_output=True, text=True, check=True
        )
        logger.info(f"Full backup output: {result.stdout.strip()}")
        backup_path = "/backups/full_backup.tar.gz"
        logger.info(f"Full backup created at {backup_path}.")
        return backup_path
    except subprocess.CalledProcessError as exc:
        logger.error(f"Full backup failed: {exc}")
        raise


@task(retries=2, name="Perform Incremental Backup")
def perform_incremental_backup(strategy: Literal["full", "incremental"]) -> Optional[str]:
    """
    Execute an incremental backup if the selected strategy is 'incremental'.
    Args:
        strategy: The backup strategy determined earlier.
    Returns:
        Path to the incremental backup file if performed, otherwise None.
    """
    logger = get_run_logger()
    if strategy != "incremental":
        logger.info("Incremental backup skipped (strategy is full).")
        return None

    logger.info("Starting incremental backup...")
    try:
        # Placeholder command; replace with actual backup command
        result = subprocess.run(
            ["echo", "Performing incremental backup..."], capture_output=True, text=True, check=True
        )
        logger.info(f"Incremental backup output: {result.stdout.strip()}")
        backup_path = "/backups/incremental_backup.tar.gz"
        logger.info(f"Incremental backup created at {backup_path}.")
        return backup_path
    except subprocess.CalledProcessError as exc:
        logger.error(f"Incremental backup failed: {exc}")
        raise


@task(retries=2, name="Verify Backup")
def verify_backup(
    full_backup_path: Optional[str], incremental_backup_path: Optional[str]
) -> bool:
    """
    Verify that the backup (full or incremental) was created successfully.
    Args:
        full_backup_path: Path returned by perform_full_backup (or None).
        incremental_backup_path: Path returned by perform_incremental_backup (or None).
    Returns:
        True if verification succeeds, otherwise raises an exception.
    """
    logger = get_run_logger()
    backup_path = full_backup_path or incremental_backup_path
    if not backup_path:
        logger.error("No backup file to verify.")
        raise ValueError("Backup verification failed: no backup produced.")

    logger.info(f"Verifying backup at {backup_path}...")
    try:
        # Placeholder verification command
        result = subprocess.run(
            ["echo", f"Verifying {backup_path}"], capture_output=True, text=True, check=True
        )
        logger.info(f"Verification output: {result.stdout.strip()}")
        logger.info("Backup verification succeeded.")
        return True
    except subprocess.CalledProcessError as exc:
        logger.error(f"Backup verification failed: {exc}")
        raise


@task(retries=2, name="Finalize Backup")
def finalize_backup(verification_passed: bool) -> None:
    """
    Finalize the backup process, e.g., clean up temporary files,
    notify stakeholders, or update metadata stores.
    Args:
        verification_passed: Result from the verify_backup task.
    """
    logger = get_run_logger()
    if not verification_passed:
        logger.error("Cannot finalize backup because verification failed.")
        raise ValueError("Finalization aborted due to failed verification.")

    logger.info("Finalizing backup...")
    try:
        # Placeholder finalization command
        subprocess.run(["echo", "Backup finalized"], check=True)
        logger.info("Backup process completed successfully.")
    except subprocess.CalledProcessError as exc:
        logger.error(f"Finalization step failed: {exc}")
        raise


# -------------------------------------------------------------------------
# Flow Definition
# -------------------------------------------------------------------------

@flow(
    name="Backup Strategy Selector",
    task_runner=SequentialTaskRunner(),
)
def backup_strategy_selector_flow() -> None:
    """
    Orchestrates the backup strategy selection and execution.
    Implements a fanout-fanin pattern where the strategy decision branches
    into full and incremental backup tasks, which are later merged for verification.
    """
    # Step 1: Start the process
    start_backup_process()

    # Step 2: Determine which strategy to use
    strategy = determine_backup_strategy()

    # Step 3: Fan‑out – run both backup tasks (each internally decides to act or skip)
    full_backup_path = perform_full_backup(strategy)
    incremental_backup_path = perform_incremental_backup(strategy)

    # Step 4: Fan‑in – verify the produced backup
    verification_passed = verify_backup(full_backup_path, incremental_backup_path)

    # Step 5: Finalize
    finalize_backup(verification_passed)


# -------------------------------------------------------------------------
# Deployment Configuration
# -------------------------------------------------------------------------

def build_deployment() -> Deployment:
    """
    Creates a Prefect deployment for the backup_strategy_selector_flow.
    The deployment runs daily at midnight UTC without catch‑up.
    """
    schedule = CronSchedule(cron="0 0 * * *", timezone="UTC")  # @daily
    deployment = Deployment.build_from_flow(
        flow=backup_strategy_selector_flow,
        name="backup_strategy_selector_deployment",
        schedule=schedule,
        work_pool_name="default-agent-pool",
        flow_name="backup_strategy_selector",
        enforce_parameter_schema=False,
        tags=["backup", "strategy"],
        description="Daily backup strategy selector deployment.",
        parameters={},  # No external parameters required
        run_config=None,
        job_variables=None,
        catchup=False,
    )
    return deployment


if __name__ == "__main__":
    # Register (or update) the deployment when this script is executed directly.
    deployment = build_deployment()
    deployment.apply()
    # Optionally, trigger a run immediately for testing:
    # backup_strategy_selector_flow()
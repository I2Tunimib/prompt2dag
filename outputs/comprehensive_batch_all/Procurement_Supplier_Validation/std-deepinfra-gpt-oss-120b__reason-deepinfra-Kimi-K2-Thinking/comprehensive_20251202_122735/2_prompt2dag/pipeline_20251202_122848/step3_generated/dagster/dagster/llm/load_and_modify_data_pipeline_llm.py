# Generated by Dagster Code Generator
# Date: 2024-06-20
# Pipeline: load_and_modify_data_pipeline
# Description: No description provided.
# Executor: DockerExecutor
# Dagster version: 1.5.0

from __future__ import annotations

from typing import Any, Dict, List

from dagster import (
    IOManager,
    In,
    Out,
    RetryPolicy,
    ResourceDefinition,
    ConfigurableResource,
    op,
    job,
    get_dagster_logger,
    io_manager,
    resource,
)
from dagster_docker import docker_executor

# ----------------------------------------------------------------------
# Resource Definitions
# ----------------------------------------------------------------------


@resource(config_schema={"path": str})
def fs_io_manager(init_context) -> IOManager:
    """Simple filesystem IO manager that reads/writes JSON files."""
    import json
    import os

    base_path = init_context.resource_config["path"]

    class SimpleFSIOManager(IOManager):
        def handle_output(self, context, obj):
            output_path = os.path.join(base_path, f"{context.step_key}.json")
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            with open(output_path, "w", encoding="utf-8") as f:
                json.dump(obj, f)

        def load_input(self, context):
            input_path = os.path.join(base_path, f"{context.upstream_output.step_key}.json")
            with open(input_path, "r", encoding="utf-8") as f:
                return json.load(f)

    return SimpleFSIOManager()


class LoadModifyServiceResource(ConfigurableResource):
    """Placeholder for the Load‑and‑Modify Service API client."""

    endpoint: str
    api_key: str

    def fetch_and_modify(self) -> List[Dict[str, Any]]:
        logger = get_dagster_logger()
        logger.info("Fetching supplier data from %s", self.endpoint)
        # Placeholder implementation – replace with real API call
        return [{"supplier_id": 1, "name": "Acme Corp", "status": "raw"}]


class ReconciliationServiceResource(ConfigurableResource):
    """Placeholder for the Entity Reconciliation Service API client."""

    endpoint: str
    api_key: str

    def reconcile(self, records: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        logger = get_dagster_logger()
        logger.info("Reconciling %d records via %s", len(records), self.endpoint)
        # Placeholder implementation – replace with real reconciliation logic
        for rec in records:
            rec["reconciled"] = True
        return records


class SaveServiceResource(ConfigurableResource):
    """Placeholder for the Save Service API client."""

    endpoint: str
    api_key: str

    def save(self, records: List[Dict[str, Any]]) -> None:
        logger = get_dagster_logger()
        logger.info("Saving %d validated records to %s", len(records), self.endpoint)
        # Placeholder implementation – replace with real save logic
        pass


class MongoDBResource(ConfigurableResource):
    """Simple MongoDB client wrapper."""

    uri: str
    database: str

    def get_client(self):
        from pymongo import MongoClient

        return MongoClient(self.uri)[self.database]

    def insert_records(self, collection_name: str, records: List[Dict[str, Any]]) -> None:
        client = self.get_client()
        collection = client[collection_name]
        collection.insert_many(records)


class IntertwinoAPIResource(ConfigurableResource):
    """Placeholder for Intertwino API client."""

    endpoint: str
    api_key: str


class DockerNetworkAppResource(ConfigurableResource):
    """Placeholder for a custom Docker network configuration."""

    network_name: str


class WikidataAPIResource(ConfigurableResource):
    """Placeholder for Wikidata Entity API client."""

    endpoint: str = "https://www.wikidata.org/wiki/Special:EntityData"


# ----------------------------------------------------------------------
# Ops
# ----------------------------------------------------------------------


@op(
    out=Out(dagster_type=List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=1),
    description="Load and modify supplier data using the Load‑and‑Modify Service API.",
    required_resource_keys={"api_load_modify_service"},
)
def load_and_modify_data(context) -> List[Dict[str, Any]]:
    """Fetch raw supplier data and apply initial transformations."""
    service: LoadModifyServiceResource = context.resources.api_load_modify_service
    data = service.fetch_and_modify()
    context.log.info("Loaded %d supplier records.", len(data))
    return data


@op(
    ins={"raw_data": In(dagster_type=List[Dict[str, Any]])},
    out=Out(dagster_type=List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=1),
    description="Reconcile supplier names against Wikidata entities.",
    required_resource_keys={"api_reconciliation_service", "wikidata_api"},
)
def reconcile_supplier_names(context, raw_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Perform entity reconciliation using the reconciliation service and Wikidata."""
    recon_service: ReconciliationServiceResource = context.resources.api_reconciliation_service
    wikidata: WikidataAPIResource = context.resources.wikidata_api

    # In a real implementation, wikidata would be used inside recon_service.reconcile()
    reconciled = recon_service.reconcile(raw_data)
    context.log.info("Reconciled %d records.", len(reconciled))
    return reconciled


@op(
    ins={"validated_data": In(dagster_type=List[Dict[str, Any]])},
    out=Out(dagster_type=None),
    retry_policy=RetryPolicy(max_retries=1),
    description="Save the final validated supplier data using the Save Service API and MongoDB.",
    required_resource_keys={"api_save_service", "mongodb_instance"},
)
def save_validated_data(context, validated_data: List[Dict[str, Any]]) -> None:
    """Persist validated supplier data to external services."""
    save_service: SaveServiceResource = context.resources.api_save_service
    mongo: MongoDBResource = context.resources.mongodb_instance

    # Save via external API
    save_service.save(validated_data)
    context.log.info("Data saved via Save Service API.")

    # Also store in MongoDB for downstream consumption
    mongo.insert_records(collection_name="validated_suppliers", records=validated_data)
    context.log.info("Data inserted into MongoDB collection 'validated_suppliers'.")


# ----------------------------------------------------------------------
# Job Definition
# ----------------------------------------------------------------------


@job(
    executor_def=docker_executor,
    resource_defs={
        "fs_io_manager": fs_io_manager,
        "api_load_modify_service": LoadModifyServiceResource,
        "api_reconciliation_service": ReconciliationServiceResource,
        "api_save_service": SaveServiceResource,
        "mongodb_instance": MongoDBResource,
        "intertwino_api": IntertwinoAPIResource,
        "docker_network_app": DockerNetworkAppResource,
        "wikidata_api": WikidataAPIResource,
    },
    description="No description provided.",
)
def load_and_modify_data_pipeline():
    """Sequential pipeline that loads, reconciles, and saves supplier data."""
    raw = load_and_modify_data()
    reconciled = reconcile_supplier_names(raw_data=raw)
    save_validated_data(validated_data=reconciled)


# ----------------------------------------------------------------------
# Example resource configuration (to be used in deployment)
# ----------------------------------------------------------------------
# The following dictionary can be supplied to Dagster's run config or
# environment YAML to instantiate the resources with concrete values.

example_resource_config = {
    "resources": {
        "fs_io_manager": {"config": {"path": "/tmp/dagster_io"}},
        "api_load_modify_service": {
            "config": {"endpoint": "https://api.example.com/load-modify", "api_key": "YOUR_KEY"}
        },
        "api_reconciliation_service": {
            "config": {"endpoint": "https://api.example.com/reconcile", "api_key": "YOUR_KEY"}
        },
        "api_save_service": {
            "config": {"endpoint": "https://api.example.com/save", "api_key": "YOUR_KEY"}
        },
        "mongodb_instance": {
            "config": {"uri": "mongodb://localhost:27017", "database": "supplier_db"}
        },
        "intertwino_api": {"config": {"endpoint": "https://api.intertwino.com", "api_key": "YOUR_KEY"}},
        "docker_network_app": {"config": {"network_name": "app_network"}},
        "wikidata_api": {"config": {}},
    }
}
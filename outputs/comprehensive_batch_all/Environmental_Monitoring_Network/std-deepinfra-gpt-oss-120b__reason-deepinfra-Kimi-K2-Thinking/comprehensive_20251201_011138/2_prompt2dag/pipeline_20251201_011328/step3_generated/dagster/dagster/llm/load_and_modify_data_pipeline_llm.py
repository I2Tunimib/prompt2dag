# Generated by Dagster code generator
# Date: 2024-06-27
# Pipeline: load_and_modify_data_pipeline
# Description: No description provided.

from dagster import (
    op,
    job,
    RetryPolicy,
    ResourceDefinition,
    In,
    Out,
    Nothing,
    ConfigurableResource,
    InitResourceContext,
    executor,
    DockerExecutor,
    fs_io_manager,
)

# ----------------------------------------------------------------------
# Resource placeholders
# ----------------------------------------------------------------------


class MongoDBResource(ConfigurableResource):
    """Placeholder for a MongoDB connection resource."""

    uri: str = "mongodb://localhost:27017"

    def get_client(self):
        # In production, return a pymongo.MongoClient instance
        return None


class IntertwinoAPIResource(ConfigurableResource):
    """Placeholder for Intertwino internal API client."""

    base_url: str = "http://intertwino.api"

    def request(self, endpoint: str, **kwargs):
        return None


class LoadModifyServiceResource(ConfigurableResource):
    """Placeholder for Load‑and‑Modify Service."""

    def process(self, data):
        return data


class ReconciliationServiceResource(ConfigurableResource):
    """Placeholder for Reconciliation (Geocoding) Service."""

    def reconcile(self, data):
        return data


class HereGeocodingAPIResource(ConfigurableResource):
    """Placeholder for HERE Geocoding API."""

    api_key: str = "YOUR_HERE_API_KEY"

    def geocode(self, address: str):
        return None


class OpenMeteoAPIResource(ConfigurableResource):
    """Placeholder for OpenMeteo Weather API."""

    def fetch_weather(self, location):
        return None


class GeoapifyLandUseAPIResource(ConfigurableResource):
    """Placeholder for Geoapify Land‑Use API."""

    api_key: str = "YOUR_GEOAPIFY_API_KEY"

    def fetch_land_use(self, location):
        return None


class WorldPopDensityAPIResource(ConfigurableResource):
    """Placeholder for WorldPop Population Density API."""

    def fetch_density(self, location):
        return None


class ColumnExtensionServiceResource(ConfigurableResource):
    """Placeholder for Column Extension Service."""

    def extend(self, data, extra_columns):
        return data


class SaveServiceResource(ConfigurableResource):
    """Placeholder for Save Service."""

    def save(self, data, path):
        return None


class AppNetworkResource(ConfigurableResource):
    """Placeholder for a custom Docker network."""

    name: str = "app_network"


# ----------------------------------------------------------------------
# Ops
# ----------------------------------------------------------------------


@op(
    name="load_and_modify_data",
    description="Loads raw data and applies initial modifications.",
    out=Out(dict),
    retry_policy=RetryPolicy(max_retries=1, delay=5),
    required_resource_keys={"load_modify_service"},
)
def load_and_modify_data(context: InitResourceContext) -> dict:
    """Load raw data and apply the Load‑and‑Modify service."""
    service: LoadModifyServiceResource = context.resources.load_modify_service
    # Placeholder: replace with actual loading logic
    raw_data = {"raw": "data"}
    modified = service.process(raw_data)
    context.log.info("Data loaded and modified.")
    return modified


@op(
    name="geocode_reconciliation",
    description="Performs geocode reconciliation on the dataset.",
    ins={"data": In(dict)},
    out=Out(dict),
    retry_policy=RetryPolicy(max_retries=1, delay=5),
    required_resource_keys={"reconciliation_service", "here_geocoding_api"},
)
def geocode_reconciliation(context: InitResourceContext, data: dict) -> dict:
    """Reconcile geocoding information using the reconciliation service."""
    recon_service: ReconciliationServiceResource = context.resources.reconciliation_service
    geocode_api: HereGeocodingAPIResource = context.resources.here_geocoding_api
    reconciled = recon_service.reconcile(data)
    # Example usage of geocode API (placeholder)
    _ = geocode_api.geocode("example address")
    context.log.info("Geocode reconciliation completed.")
    return reconciled


@op(
    name="open_meteo_extension",
    description="Extends dataset with OpenMeteo weather data.",
    ins={"data": In(dict)},
    out=Out(dict),
    retry_policy=RetryPolicy(max_retries=1, delay=5),
    required_resource_keys={"open_meteo_api", "column_extension_service"},
)
def open_meteo_extension(context: InitResourceContext, data: dict) -> dict:
    """Add weather information from OpenMeteo to the dataset."""
    weather_api: OpenMeteoAPIResource = context.resources.open_meteo_api
    extender: ColumnExtensionServiceResource = context.resources.column_extension_service
    weather = weather_api.fetch_weather(data)
    extended = extender.extend(data, {"weather": weather})
    context.log.info("OpenMeteo data extension completed.")
    return extended


@op(
    name="land_use_extension",
    description="Adds land‑use information from Geoapify.",
    ins={"data": In(dict)},
    out=Out(dict),
    retry_policy=RetryPolicy(max_retries=1, delay=5),
    required_resource_keys={"geoapify_land_use_api", "column_extension_service"},
)
def land_use_extension(context: InitResourceContext, data: dict) -> dict:
    """Enrich dataset with land‑use data."""
    land_use_api: GeoapifyLandUseAPIResource = context.resources.geoapify_land_use_api
    extender: ColumnExtensionServiceResource = context.resources.column_extension_service
    land_use = land_use_api.fetch_land_use(data)
    extended = extender.extend(data, {"land_use": land_use})
    context.log.info("Land use extension completed.")
    return extended


@op(
    name="population_density_extension",
    description="Adds population density data from WorldPop.",
    ins={"data": In(dict)},
    out=Out(dict),
    retry_policy=RetryPolicy(max_retries=1, delay=5),
    required_resource_keys={"worldpop_density_api", "column_extension_service"},
)
def population_density_extension(context: InitResourceContext, data: dict) -> dict:
    """Enrich dataset with population density information."""
    density_api: WorldPopDensityAPIResource = context.resources.worldpop_density_api
    extender: ColumnExtensionServiceResource = context.resources.column_extension_service
    density = density_api.fetch_density(data)
    extended = extender.extend(data, {"population_density": density})
    context.log.info("Population density extension completed.")
    return extended


@op(
    name="environmental_risk_calculation",
    description="Calculates environmental risk based on enriched data.",
    ins={"data": In(dict)},
    out=Out(dict),
    retry_policy=RetryPolicy(max_retries=1, delay=5),
    required_resource_keys=set(),
)
def environmental_risk_calculation(context: InitResourceContext, data: dict) -> dict:
    """Placeholder for environmental risk calculation logic."""
    # Insert actual risk calculation here
    data["environmental_risk"] = "calculated_value"
    context.log.info("Environmental risk calculation completed.")
    return data


@op(
    name="save_final_data",
    description="Persists the final dataset using the Save Service.",
    ins={"data": In(dict)},
    out=Out(Nothing),
    retry_policy=RetryPolicy(max_retries=1, delay=5),
    required_resource_keys={"save_service"},
)
def save_final_data(context: InitResourceContext, data: dict) -> Nothing:
    """Save the final dataset to the shared data directory."""
    saver: SaveServiceResource = context.resources.save_service
    saver.save(data, path="/data/final_output.parquet")
    context.log.info("Final data saved.")
    return Nothing


# ----------------------------------------------------------------------
# Job definition
# ----------------------------------------------------------------------


docker_executor_def = DockerExecutor(
    # Example configuration; adjust image names and network as needed.
    # The same image is used for all ops; in practice you may set per‑op images.
    container_image="python:3.11-slim",
    network="app_network",
    env_vars={"PYTHONUNBUFFERED": "1"},
    # Mount the shared data directory via the fs_io_manager resource.
    # The actual volume mapping is handled by the io manager configuration.
)


@job(
    name="load_and_modify_data_pipeline",
    description="No description provided.",
    executor_def=docker_executor_def,
    resource_defs={
        "io_manager": fs_io_manager,
        "data_dir_volume": ResourceDefinition.hardcoded_resource(None),  # placeholder
        "mongodb": MongoDBResource(),
        "intertwino_api": IntertwinoAPIResource(),
        "load_modify_service": LoadModifyServiceResource(),
        "reconciliation_service": ReconciliationServiceResource(),
        "here_geocoding_api": HereGeocodingAPIResource(),
        "open_meteo_api": OpenMeteoAPIResource(),
        "geoapify_land_use_api": GeoapifyLandUseAPIResource(),
        "worldpop_density_api": WorldPopDensityAPIResource(),
        "column_extension_service": ColumnExtensionServiceResource(),
        "save_service": SaveServiceResource(),
        "app_network": AppNetworkResource(),
    },
)
def load_and_modify_data_pipeline():
    """Sequential pipeline that loads data, enriches it through several services,
    calculates environmental risk, and finally saves the result.
    """
    loaded = load_and_modify_data()
    geocoded = geocode_reconciliation(loaded)
    weather = open_meteo_extension(geocoded)
    land_use = land_use_extension(weather)
    density = population_density_extension(land_use)
    risk = environmental_risk_calculation(density)
    save_final_data(risk)


# ----------------------------------------------------------------------
# Schedule (disabled)
# ----------------------------------------------------------------------


# The schedule is intentionally disabled as per the specification.
# To enable, uncomment and adjust the cron schedule as needed.

# from dagster import ScheduleDefinition, default_job_status

# schedule = ScheduleDefinition(
#     job=load_and_modify_data_pipeline,
#     cron_schedule="0 0 * * *",  # placeholder
#     execution_timezone="UTC",
#     default_status=default_job_status,
#     enabled=False,
# )
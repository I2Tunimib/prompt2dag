# Generated by Dagster code generator
# Date: 2024-06-12
# Pipeline: load_and_modify_data_pipeline
# Description: No description provided.

from typing import Any, Dict

from dagster import (
    op,
    job,
    In,
    Out,
    RetryPolicy,
    ConfigurableResource,
    ResourceDefinition,
    IOManager,
    io_manager,
    get_dagster_logger,
)
from dagster_docker import docker_executor

# ----------------------------------------------------------------------
# IO Manager
# ----------------------------------------------------------------------


@io_manager
def fs_io_manager(init_context) -> IOManager:
    """Simple filesystem IO manager that writes JSON-serializable objects to a shared volume."""
    import json
    import os

    base_path = init_context.resource_config.get("base_path", "/data")

    class SimpleFSIOManager(IOManager):
        def handle_output(self, context, obj):
            path = os.path.join(base_path, f"{context.step_key}.json")
            with open(path, "w", encoding="utf-8") as f:
                json.dump(obj, f)

        def load_input(self, context):
            path = os.path.join(base_path, f"{context.upstream_output.step_key}.json")
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)

    return SimpleFSIOManager()


# ----------------------------------------------------------------------
# Resource Stubs
# ----------------------------------------------------------------------


class LoadModifyAPIResource(ConfigurableResource):
    """Stub for Load‑and‑Modify Service API."""

    endpoint: str = "http://load-modify-service"

    def load_and_modify(self, data: Dict[str, Any]) -> Dict[str, Any]:
        logger = get_dagster_logger()
        logger.info("Calling Load‑and‑Modify API at %s", self.endpoint)
        # Placeholder implementation
        data["load_modify"] = "completed"
        return data


class ReconciliationAPIResource(ConfigurableResource):
    """Stub for Reconciliation Service API."""

    endpoint: str = "http://reconciliation-service"

    def reconcile(self, data: Dict[str, Any]) -> Dict[str, Any]:
        logger = get_dagster_logger()
        logger.info("Calling Reconciliation API at %s", self.endpoint)
        data["reconciliation"] = "completed"
        return data


class HereGeocodingAPIResource(ConfigurableResource):
    """Stub for HERE Geocoding API."""

    endpoint: str = "https://geocode.search.hereapi.com/v1"

    def geocode(self, data: Dict[str, Any]) -> Dict[str, Any]:
        logger = get_dagster_logger()
        logger.info("Calling HERE Geocoding API at %s", self.endpoint)
        data["geocoding"] = "completed"
        return data


class OpenMeteoAPIResource(ConfigurableResource):
    """Stub for OpenMeteo Weather API."""

    endpoint: str = "https://api.open-meteo.com/v1/forecast"

    def extend_weather(self, data: Dict[str, Any]) -> Dict[str, Any]:
        logger = get_dagster_logger()
        logger.info("Calling OpenMeteo API at %s", self.endpoint)
        data["weather"] = "extended"
        return data


class GeoapifyLandUseAPIResource(ConfigurableResource):
    """Stub for Geoapify Land‑Use API."""

    endpoint: str = "https://api.geoapify.com/v2/landuse"

    def extend_land_use(self, data: Dict[str, Any]) -> Dict[str, Any]:
        logger = get_dagster_logger()
        logger.info("Calling Geoapify Land‑Use API at %s", self.endpoint)
        data["land_use"] = "extended"
        return data


class WorldPopDensityAPIResource(ConfigurableResource):
    """Stub for WorldPop Population Density API."""

    endpoint: str = "https://worldpop.org/api"

    def extend_population(self, data: Dict[str, Any]) -> Dict[str, Any]:
        logger = get_dagster_logger()
        logger.info("Calling WorldPop Density API at %s", self.endpoint)
        data["population_density"] = "extended"
        return data


class ColumnExtensionAPIResource(ConfigurableResource):
    """Stub for Column Extension Service API."""

    endpoint: str = "http://column-extension-service"

    def calculate_risk(self, data: Dict[str, Any]) -> Dict[str, Any]:
        logger = get_dagster_logger()
        logger.info("Calling Column Extension API at %s", self.endpoint)
        data["environmental_risk"] = "calculated"
        return data


class SaveServiceAPIResource(ConfigurableResource):
    """Stub for Save Service API."""

    endpoint: str = "http://save-service"

    def save(self, data: Dict[str, Any]) -> None:
        logger = get_dagster_logger()
        logger.info("Saving final dataset via Save Service at %s", self.endpoint)
        # Placeholder: pretend we saved the data
        logger.info("Data saved successfully.")


class MongoDBResource(ConfigurableResource):
    """Stub for MongoDB Metadata Store."""

    uri: str = "mongodb://localhost:27017"

    def get_client(self):
        # In a real implementation, return a pymongo.MongoClient
        return None


class IntertwinoAPIResource(ConfigurableResource):
    """Stub for Intertwino API."""

    endpoint: str = "http://intertwino-service"

    def enrich(self, data: Dict[str, Any]) -> Dict[str, Any]:
        logger = get_dagster_logger()
        logger.info("Calling Intertwino API at %s", self.endpoint)
        data["intertwino"] = "enriched"
        return data


class DockerNetworkResource(ConfigurableResource):
    """Stub for custom Docker network resource."""

    network_name: str = "app_network"


# ----------------------------------------------------------------------
# Ops
# ----------------------------------------------------------------------


@op(
    out=Out(Dict[str, Any]),
    retry_policy=RetryPolicy(max_retries=1),
    description="Load and modify station data using the Load‑and‑Modify Service API.",
    required_resource_keys={"load_modify_api"},
)
def load_and_modify_data(context) -> Dict[str, Any]:
    logger = context.log
    logger.info("Starting Load and Modify Station Data step.")
    # Initial empty payload; real implementation would load raw data.
    raw_data: Dict[str, Any] = {}
    result = context.resources.load_modify_api.load_and_modify(raw_data)
    logger.info("Load and Modify step completed.")
    return result


@op(
    ins={"data": In(Dict[str, Any])},
    out=Out(Dict[str, Any]),
    retry_policy=RetryPolicy(max_retries=1),
    description="Perform geocode reconciliation using the Reconciliation and HERE Geocoding APIs.",
    required_resource_keys={"reconciliation_api", "here_geocoding_api"},
)
def geocode_reconciliation(context, data: Dict[str, Any]) -> Dict[str, Any]:
    logger = context.log
    logger.info("Starting Geocode Reconciliation step.")
    data = context.resources.reconciliation_api.reconcile(data)
    data = context.resources.here_geocoding_api.geocode(data)
    logger.info("Geocode Reconciliation step completed.")
    return data


@op(
    ins={"data": In(Dict[str, Any])},
    out=Out(Dict[str, Any]),
    retry_policy=RetryPolicy(max_retries=1),
    description="Extend dataset with OpenMeteo weather data.",
    required_resource_keys={"openmeteo_api"},
)
def openmeteo_extension(context, data: Dict[str, Any]) -> Dict[str, Any]:
    logger = context.log
    logger.info("Starting OpenMeteo Weather Data Extension step.")
    data = context.resources.openmeteo_api.extend_weather(data)
    logger.info("OpenMeteo extension completed.")
    return data


@op(
    ins={"data": In(Dict[str, Any])},
    out=Out(Dict[str, Any]),
    retry_policy=RetryPolicy(max_retries=1),
    description="Add land‑use classification using the Geoapify Land‑Use API.",
    required_resource_keys={"geoapify_land_use_api"},
)
def land_use_extension(context, data: Dict[str, Any]) -> Dict[str, Any]:
    logger = context.log
    logger.info("Starting Land Use Classification Extension step.")
    data = context.resources.geoapify_land_use_api.extend_land_use(data)
    logger.info("Land Use extension completed.")
    return data


@op(
    ins={"data": In(Dict[str, Any])},
    out=Out(Dict[str, Any]),
    retry_policy=RetryPolicy(max_retries=1),
    description="Add population density information using the WorldPop API.",
    required_resource_keys={"worldpop_density_api"},
)
def population_density_extension(context, data: Dict[str, Any]) -> Dict[str, Any]:
    logger = context.log
    logger.info("Starting Population Density Extension step.")
    data = context.resources.worldpop_density_api.extend_population(data)
    logger.info("Population Density extension completed.")
    return data


@op(
    ins={"data": In(Dict[str, Any])},
    out=Out(Dict[str, Any]),
    retry_policy=RetryPolicy(max_retries=1),
    description="Calculate environmental risk using the Column Extension Service API.",
    required_resource_keys={"column_extension_api"},
)
def environmental_risk_calculation(context, data: Dict[str, Any]) -> Dict[str, Any]:
    logger = context.log
    logger.info("Starting Environmental Risk Calculation step.")
    data = context.resources.column_extension_api.calculate_risk(data)
    logger.info("Environmental Risk calculation completed.")
    return data


@op(
    ins={"data": In(Dict[str, Any])},
    out=Out(None),
    retry_policy=RetryPolicy(max_retries=1),
    description="Persist the final enriched dataset using the Save Service API.",
    required_resource_keys={"save_service_api"},
)
def save_final_data(context, data: Dict[str, Any]) -> None:
    logger = context.log
    logger.info("Starting Save Final Enriched Dataset step.")
    context.resources.save_service_api.save(data)
    logger.info("Save step completed.")


# ----------------------------------------------------------------------
# Job Definition
# ----------------------------------------------------------------------


@job(
    executor_def=docker_executor,
    description="No description provided.",
    resource_defs={
        "fs_io_manager": fs_io_manager.configured({"base_path": "/data"}),
        "load_modify_api": LoadModifyAPIResource(),
        "reconciliation_api": ReconciliationAPIResource(),
        "here_geocoding_api": HereGeocodingAPIResource(),
        "openmeteo_api": OpenMeteoAPIResource(),
        "geoapify_land_use_api": GeoapifyLandUseAPIResource(),
        "worldpop_density_api": WorldPopDensityAPIResource(),
        "column_extension_api": ColumnExtensionAPIResource(),
        "save_service_api": SaveServiceAPIResource(),
        "mongodb": MongoDBResource(),
        "intertwino_api": IntertwinoAPIResource(),
        "docker_network_app_network": DockerNetworkResource(),
    },
    tags={"dagster_version": "1.5.0"},
)
def load_and_modify_data_pipeline():
    """Sequential pipeline that loads station data, enriches it with multiple external services,
    calculates environmental risk, and finally persists the enriched dataset.
    """
    loaded = load_and_modify_data()
    geocoded = geocode_reconciliation(loaded)
    weather = openmeteo_extension(geocoded)
    land_use = land_use_extension(weather)
    population = population_density_extension(land_use)
    risk = environmental_risk_calculation(population)
    save_final_data(risk)
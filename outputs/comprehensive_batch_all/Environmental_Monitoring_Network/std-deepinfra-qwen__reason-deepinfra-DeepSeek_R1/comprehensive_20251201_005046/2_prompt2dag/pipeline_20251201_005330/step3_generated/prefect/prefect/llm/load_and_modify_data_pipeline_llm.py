# Generated by Prefect 2.x Code Generator
# Date: [Current Date]
# Prefect Version: 2.14.0

from prefect import flow, task, get_run_logger
from prefect_docker import DockerContainer
from prefect_docker.credentials import DockerHost
from prefect.blocks.system import Secret
from prefect.filesystems import LocalFileSystem
from prefect.task_runners import SequentialTaskRunner

# Load secrets and resources
data_dir = LocalFileSystem.load("data_dir")
load_and_modify_service = Secret.load("load_and_modify_service")
reconciliation_service = Secret.load("reconciliation_service")
openmeteo_service = Secret.load("openmeteo_service")
geoapify_land_use_api = Secret.load("geoapify_land_use_api")
worldpop_density_api = Secret.load("worldpop_density_api")
column_extension_service = Secret.load("column_extension_service")
save_service = Secret.load("save_service")
docker_network = Secret.load("docker_network")
mongodb = Secret.load("mongodb")
intertwino_api = Secret.load("intertwino_api")

# Define tasks
@task(retries=1, name="Load and Modify Data")
def load_and_modify_data():
    logger = get_run_logger()
    logger.info("Starting Load and Modify Data task")
    container = DockerContainer(
        image="i2t-backendwithintertwino6-load-and-modify:latest",
        env={
            "DATASET_ID": "2",
            "DATE_COLUMN": "installation_date",
            "TABLE_NAME_PREFIX": "JOT_",
        },
        docker_host=DockerHost.load("docker_network"),
        network_mode=docker_network.get(),
    )
    container.run()
    logger.info("Completed Load and Modify Data task")

@task(retries=1, name="Reconcile Geocoding")
def reconcile_geocoding():
    logger = get_run_logger()
    logger.info("Starting Reconcile Geocoding task")
    container = DockerContainer(
        image="i2t-backendwithintertwino6-reconciliation:latest",
        env={
            "PRIMARY_COLUMN": "location",
            "RECONCILIATOR_ID": "geocodingHere",
            "API_TOKEN": reconciliation_service.get(),
            "DATASET_ID": "2",
        },
        docker_host=DockerHost.load("docker_network"),
        network_mode=docker_network.get(),
    )
    container.run()
    logger.info("Completed Reconcile Geocoding task")

@task(retries=1, name="Extend OpenMeteo Data")
def extend_openmeteo_data():
    logger = get_run_logger()
    logger.info("Starting Extend OpenMeteo Data task")
    container = DockerContainer(
        image="i2t-backendwithintertwino6-openmeteo-extension:latest",
        env={
            "LAT_COLUMN": "latitude",
            "LON_COLUMN": "longitude",
            "DATE_COLUMN": "installation_date",
            "WEATHER_VARIABLES": "apparent_temperature_max,apparent_temperature_min,precipitation_sum,precipitation_hours",
            "DATE_SEPARATOR_FORMAT": "YYYYMMDD",
        },
        docker_host=DockerHost.load("docker_network"),
        network_mode=docker_network.get(),
    )
    container.run()
    logger.info("Completed Extend OpenMeteo Data task")

@task(retries=1, name="Extend Land Use")
def extend_land_use():
    logger = get_run_logger()
    logger.info("Starting Extend Land Use task")
    container = DockerContainer(
        image="geoapify-land-use:latest",
        env={
            "LAT_COLUMN": "latitude",
            "LON_COLUMN": "longitude",
            "OUTPUT_COLUMN": "land_use_type",
            "API_KEY": geoapify_land_use_api.get(),
        },
        docker_host=DockerHost.load("docker_network"),
        network_mode=docker_network.get(),
    )
    container.run()
    logger.info("Completed Extend Land Use task")

@task(retries=1, name="Extend Population Density")
def extend_population_density():
    logger = get_run_logger()
    logger.info("Starting Extend Population Density task")
    container = DockerContainer(
        image="worldpop-density:latest",
        env={
            "LAT_COLUMN": "latitude",
            "LON_COLUMN": "longitude",
            "OUTPUT_COLUMN": "population_density",
            "RADIUS": "5000",
        },
        docker_host=DockerHost.load("docker_network"),
        network_mode=docker_network.get(),
    )
    container.run()
    logger.info("Completed Extend Population Density task")

@task(retries=1, name="Extend Environmental Risk")
def extend_environmental_risk():
    logger = get_run_logger()
    logger.info("Starting Extend Environmental Risk task")
    container = DockerContainer(
        image="i2t-backendwithintertwino6-column-extension:latest",
        env={
            "EXTENDER_ID": "environmentalRiskCalculator",
            "INPUT_COLUMNS": "precipitation_sum,population_density,land_use_type",
            "OUTPUT_COLUMN": "risk_score",
            "CALCULATION_FORMULA": column_extension_service.get(),
        },
        docker_host=DockerHost.load("docker_network"),
        network_mode=docker_network.get(),
    )
    container.run()
    logger.info("Completed Extend Environmental Risk task")

@task(retries=1, name="Save Final Data")
def save_final_data():
    logger = get_run_logger()
    logger.info("Starting Save Final Data task")
    container = DockerContainer(
        image="i2t-backendwithintertwino6-save:latest",
        env={
            "DATASET_ID": "2",
        },
        docker_host=DockerHost.load("docker_network"),
        network_mode=docker_network.get(),
    )
    container.run()
    logger.info("Completed Save Final Data task")

# Define flow
@flow(name="load_and_modify_data_pipeline", task_runner=SequentialTaskRunner)
def load_and_modify_data_pipeline():
    logger = get_run_logger()
    logger.info("Starting load_and_modify_data_pipeline")

    load_and_modify_data_result = load_and_modify_data()
    reconcile_geocoding_result = reconcile_geocoding()
    extend_openmeteo_data_result = extend_openmeteo_data()
    extend_land_use_result = extend_land_use()
    extend_population_density_result = extend_population_density()
    extend_environmental_risk_result = extend_environmental_risk()
    save_final_data_result = save_final_data()

    logger.info("Completed load_and_modify_data_pipeline")

# Deploy the flow
if __name__ == "__main__":
    load_and_modify_data_pipeline()
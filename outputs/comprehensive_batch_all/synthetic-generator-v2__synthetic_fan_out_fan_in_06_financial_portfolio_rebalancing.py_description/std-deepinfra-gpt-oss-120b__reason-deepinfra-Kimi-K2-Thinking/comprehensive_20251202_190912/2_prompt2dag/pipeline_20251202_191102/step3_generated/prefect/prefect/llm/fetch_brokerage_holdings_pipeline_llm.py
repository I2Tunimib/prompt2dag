# Generated by Prefect Pipeline Generator
# Date: 2024-06-28
# Pipeline: fetch_brokerage_holdings_pipeline
# Description: Portfolio Rebalancing DAG

from __future__ import annotations

import json
from datetime import datetime
from typing import Any, Dict, List

from prefect import flow, task, get_run_logger
from prefect.task_runners import ConcurrentTaskRunner
from prefect.deployments import DeploymentSpec
from prefect.orion.schemas.schedules import CronSchedule
from prefect.blocks.system import Secret
from prefect.filesystems import LocalFileSystem


@task(retries=2, retry_delay_seconds=30, name="Fetch Brokerage Holdings")
def fetch_brokerage_holdings(brokerage_secret: Secret) -> List[Dict[str, Any]]:
    """
    Retrieve current holdings from a simulated brokerage API.

    The brokerage API credentials are stored in a Prefect Secret block.
    This task pretends to call the API and returns a list of holdings.

    Args:
        brokerage_secret: Prefect Secret block containing API credentials.

    Returns:
        A list of dictionaries, each representing a holding with keys such as
        ``symbol`` and ``quantity``.
    """
    logger = get_run_logger()
    logger.info("Fetching brokerage holdings using secret %s", brokerage_secret.block_name)

    # Simulated API call â€“ in a real implementation you would use ``requests`` or an SDK.
    credentials = brokerage_secret.get()
    logger.debug("Retrieved credentials: %s", credentials)

    # Mock response
    holdings = [
        {"symbol": "AAPL", "quantity": 150},
        {"symbol": "MSFT", "quantity": 80},
        {"symbol": "GOOGL", "quantity": 40},
    ]
    logger.info("Fetched %d holdings", len(holdings))
    return holdings


@task(retries=2, retry_delay_seconds=30, name="Analyze Portfolio")
def analyze_portfolio(holdings: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Perform a simple analysis of the portfolio.

    Calculates total position count and a mock risk metric.

    Args:
        holdings: List of holdings returned by ``fetch_brokerage_holdings``.

    Returns:
        A dictionary containing analysis results.
    """
    logger = get_run_logger()
    logger.info("Analyzing %d holdings", len(holdings))

    total_quantity = sum(item["quantity"] for item in holdings)
    risk_score = total_quantity / 1000  # Placeholder risk calculation

    analysis = {
        "total_positions": len(holdings),
        "total_quantity": total_quantity,
        "risk_score": round(risk_score, 3),
    }
    logger.debug("Analysis result: %s", analysis)
    return analysis


@task(retries=2, retry_delay_seconds=30, name="Aggregate and Rebalance")
def aggregate_and_rebalance(
    holdings: List[Dict[str, Any]], analysis: Dict[str, Any]
) -> List[Dict[str, Any]]:
    """
    Aggregate holdings and generate a rebalance plan.

    This mock implementation creates a simple rebalance suggestion based on
    the risk score.

    Args:
        holdings: Current holdings.
        analysis: Output from ``analyze_portfolio``.

    Returns:
        A list of rebalance actions, each containing ``symbol`` and ``target_quantity``.
    """
    logger = get_run_logger()
    logger.info("Aggregating holdings and creating rebalance plan")

    target_total = 1000  # Desired total quantity for illustration
    scaling_factor = target_total / analysis["total_quantity"]
    rebalance_plan = []

    for item in holdings:
        target_qty = int(item["quantity"] * scaling_factor)
        rebalance_plan.append(
            {"symbol": item["symbol"], "current_quantity": item["quantity"], "target_quantity": target_qty}
        )
        logger.debug(
            "Rebalance for %s: current %d -> target %d",
            item["symbol"],
            item["quantity"],
            target_qty,
        )

    logger.info("Generated rebalance plan for %d symbols", len(rebalance_plan))
    return rebalance_plan


@task(retries=2, retry_delay_seconds=30, name="Generate Trade Orders")
def generate_trade_orders(
    rebalance_plan: List[Dict[str, Any]], filesystem: LocalFileSystem
) -> str:
    """
    Convert the rebalance plan into trade order files and store them locally.

    Args:
        rebalance_plan: List of dictionaries describing desired position changes.
        filesystem: Prefect LocalFileSystem block used to write files.

    Returns:
        The path to the generated trade order JSON file.
    """
    logger = get_run_logger()
    logger.info("Generating trade orders from rebalance plan")

    orders = []
    for item in rebalance_plan:
        delta = item["target_quantity"] - item["current_quantity"]
        if delta == 0:
            continue
        order_type = "BUY" if delta > 0 else "SELL"
        orders.append(
            {
                "symbol": item["symbol"],
                "action": order_type,
                "quantity": abs(delta),
                "timestamp": datetime.utcnow().isoformat() + "Z",
            }
        )
        logger.debug(
            "Created order: %s %d %s", order_type, abs(delta), item["symbol"]
        )

    if not orders:
        logger.info("No trade orders required after rebalancing")
        return ""

    # Serialize orders to JSON
    orders_json = json.dumps(orders, indent=2)
    filename = f"trade_orders_{datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}.json"
    file_path = f"{filesystem.basepath}/{filename}"

    # Write using the filesystem block
    with filesystem.open(file_path, "w") as f:
        f.write(orders_json)

    logger.info("Trade orders written to %s", file_path)
    return file_path


@flow(
    name="fetch_brokerage_holdings_pipeline",
    task_runner=ConcurrentTaskRunner(),
    description="Portfolio Rebalancing DAG",
)
def fetch_brokerage_holdings_pipeline() -> None:
    """
    Orchestrates the portfolio rebalancing workflow.

    The flow executes the following steps sequentially:
    1. Fetch current holdings from the brokerage API.
    2. Analyze the portfolio.
    3. Create an aggregation and rebalance plan.
    4. Generate trade order files and store them locally.
    """
    logger = get_run_logger()
    logger.info("Starting fetch_brokerage_holdings_pipeline flow")

    # Load infrastructure blocks
    brokerage_secret = Secret.load("brokerage_api")
    local_fs = LocalFileSystem.load("local_filesystem")

    # Task execution respecting dependencies
    holdings = fetch_brokerage_holdings(brokerage_secret)
    analysis = analyze_portfolio(holdings)
    rebalance_plan = aggregate_and_rebalance(holdings, analysis)
    generate_trade_orders(rebalance_plan, local_fs)

    logger.info("Pipeline execution completed")


# Deployment specification
DeploymentSpec(
    name="fetch_brokerage_holdings_pipeline_deployment",
    flow=fetch_brokerage_holdings_pipeline,
    schedule=CronSchedule(cron="@daily", timezone="UTC", day_or=False),
    tags=["portfolio", "rebalancing"],
    work_pool_name="default-agent-pool",
    parameters={},
    description="Daily portfolio rebalancing deployment",
    enforce_parameter_schema=False,
)


if __name__ == "__main__":
    # Allows local execution for testing/debugging
    fetch_brokerage_holdings_pipeline()
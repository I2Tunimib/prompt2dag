# Generated by Dagster Pipeline Generator
# Date: 2024-06-13
# Pipeline: query_sales_data_pipeline
# Description: Sequential linear pipeline that generates daily sales reports by querying PostgreSQL sales data,
# converting it to CSV, creating a PDF chart, and emailing the report to management.

from pathlib import Path
from typing import Any, Dict

import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

from dagster import (
    op,
    job,
    In,
    Out,
    RetryPolicy,
    ConfigurableResource,
    InitResourceContext,
    ResourceDefinition,
    fs_io_manager,
    InProcessExecutor,
    ScheduleDefinition,
    DefaultScheduleStatus,
    Definitions,
    Nothing,
    Output,
)


# -------------------------------------------------------------------------
# Resource definitions
# -------------------------------------------------------------------------

class PostgresSalesDBResource(ConfigurableResource):
    """Resource for connecting to the PostgreSQL sales database."""

    host: str
    port: int
    database: str
    user: str
    password: str

    def get_connection(self) -> Any:
        """Create and return a SQLAlchemy engine."""
        from sqlalchemy import create_engine

        url = (
            f"postgresql://{self.user}:{self.password}"
            f"@{self.host}:{self.port}/{self.database}"
        )
        return create_engine(url)


class EmailSMTPResource(ConfigurableResource):
    """Resource for sending emails via SMTP."""

    host: str
    port: int
    username: str
    password: str
    use_tls: bool = True
    from_address: str = "no-reply@example.com"

    def send_email(
        self,
        to: str,
        subject: str,
        body: str,
        attachments: Dict[str, Path] | None = None,
    ) -> None:
        """Send an email with optional file attachments."""
        import smtplib
        from email.message import EmailMessage
        from email.utils import make_msgid

        msg = EmailMessage()
        msg["Subject"] = subject
        msg["From"] = self.from_address
        msg["To"] = to
        msg.set_content(body)

        # Attach files if provided
        if attachments:
            for filename, path in attachments.items():
                with open(path, "rb") as f:
                    file_data = f.read()
                maintype, subtype = ("application", "octet-stream")
                msg.add_attachment(
                    file_data,
                    maintype=maintype,
                    subtype=subtype,
                    filename=filename,
                )

        # Connect and send
        if self.use_tls:
            server = smtplib.SMTP(self.host, self.port)
            server.starttls()
        else:
            server = smtplib.SMTP_SSL(self.host, self.port)

        server.login(self.username, self.password)
        server.send_message(msg)
        server.quit()


# -------------------------------------------------------------------------
# Ops
# -------------------------------------------------------------------------

@op(
    name="Query Sales Data",
    description="Query daily sales data from the PostgreSQL sales database.",
    out=Out(pd.DataFrame),
    retry_policy=RetryPolicy(max_retries=2),
    required_resource_keys={"postgres_sales_db"},
)
def query_sales_data(context: InitResourceContext) -> pd.DataFrame:
    """Fetch sales data for the current day from PostgreSQL."""
    import datetime

    engine = context.resources.postgres_sales_db.get_connection()
    today = datetime.date.today()
    query = """
        SELECT *
        FROM sales
        WHERE sale_date = :sale_date
    """
    df = pd.read_sql_query(query, con=engine, params={"sale_date": today})
    context.log.info(f"Fetched {len(df)} rows of sales data for {today}.")
    return df


@op(
    name="Transform Sales Data to CSV",
    description="Convert the sales DataFrame to a CSV file stored on the local temporary filesystem.",
    ins={"sales_df": In(pd.DataFrame)},
    out=Out(str),  # returns the CSV file path
    required_resource_keys={"local_tmp_fs"},
)
def transform_to_csv(context: InitResourceContext, sales_df: pd.DataFrame) -> str:
    """Write the sales DataFrame to a CSV file in the temporary filesystem."""
    tmp_dir = Path(context.resources.local_tmp_fs.base_dir) / "sales_reports"
    tmp_dir.mkdir(parents=True, exist_ok=True)
    csv_path = tmp_dir / "sales_data.csv"
    sales_df.to_csv(csv_path, index=False)
    context.log.info(f"Sales data written to CSV at {csv_path}.")
    return str(csv_path)


@op(
    name="Generate PDF Chart",
    description="Create a PDF chart from the CSV sales data.",
    ins={"csv_path": In(str)},
    out=Out(str),  # returns the PDF file path
    required_resource_keys={"local_tmp_fs"},
)
def generate_pdf_chart(context: InitResourceContext, csv_path: str) -> str:
    """Read the CSV file, generate a chart, and save it as a PDF."""
    df = pd.read_csv(csv_path)

    # Example chart: total sales per product
    summary = df.groupby("product_name")["sale_amount"].sum().sort_values(ascending=False)

    plt.figure(figsize=(8.5, 11))
    summary.plot(kind="bar")
    plt.title("Total Sales per Product")
    plt.xlabel("Product")
    plt.ylabel("Sales Amount")
    plt.tight_layout()

    tmp_dir = Path(context.resources.local_tmp_fs.base_dir) / "sales_reports"
    pdf_path = tmp_dir / "sales_report.pdf"
    with PdfPages(pdf_path) as pdf:
        pdf.savefig(plt.gcf())
    plt.close()

    context.log.info(f"PDF chart generated at {pdf_path}.")
    return str(pdf_path)


@op(
    name="Email Sales Report",
    description="Email the generated PDF sales report to management.",
    ins={"pdf_path": In(str)},
    out=Out(Nothing),
    retry_policy=RetryPolicy(max_retries=2),
    required_resource_keys={"email_smtp"},
)
def email_sales_report(context: InitResourceContext, pdf_path: str) -> Nothing:
    """Send an email with the PDF report attached."""
    to_address = "management@example.com"
    subject = "Daily Sales Report"
    body = "Please find attached the sales report for today."

    attachments = {"sales_report.pdf": Path(pdf_path)}
    context.resources.email_smtp.send_email(
        to=to_address,
        subject=subject,
        body=body,
        attachments=attachments,
    )
    context.log.info(f"Email sent to {to_address} with attachment {pdf_path}.")
    return Nothing


# -------------------------------------------------------------------------
# Job definition
# -------------------------------------------------------------------------

@job(
    name="query_sales_data_pipeline",
    description=(
        "Sequential linear pipeline that generates daily sales reports by querying PostgreSQL "
        "sales data, converting it to CSV, creating a PDF chart, and emailing the report to management."
    ),
    resource_defs={
        "postgres_sales_db": PostgresSalesDBResource,
        "local_tmp_fs": ResourceDefinition.hardcoded_resource(
            # The fs_io_manager expects a dict with a "base_dir" key.
            {"base_dir": "/tmp/dagster_sales_reports"}
        ),
        "email_smtp": EmailSMTPResource,
        "io_manager": fs_io_manager,
    },
    executor_def=InProcessExecutor(),
)
def query_sales_data_pipeline():
    """Dagster job orchestrating the daily sales reporting workflow."""
    sales_df = query_sales_data()
    csv_path = transform_to_csv(sales_df)
    pdf_path = generate_pdf_chart(csv_path)
    email_sales_report(pdf_path)


# -------------------------------------------------------------------------
# Schedule (disabled by default)
# -------------------------------------------------------------------------

daily_schedule = ScheduleDefinition(
    job=query_sales_data_pipeline,
    cron_schedule="@daily",
    execution_timezone="UTC",
    default_status=DefaultScheduleStatus.STOPPED,  # Disabled
    description="Run the sales reporting pipeline daily at midnight UTC.",
)


# -------------------------------------------------------------------------
# Definitions (entry point for Dagster UI / CLI)
# -------------------------------------------------------------------------

defs = Definitions(
    jobs=[query_sales_data_pipeline],
    schedules=[daily_schedule],
    resources={
        "postgres_sales_db": PostgresSalesDBResource(
            host="postgres.example.com",
            port=5432,
            database="salesdb",
            user="sales_user",
            password="secure_password",
        ),
        "email_smtp": EmailSMTPResource(
            host="smtp.example.com",
            port=587,
            username="smtp_user",
            password="smtp_password",
            use_tls=True,
            from_address="reports@example.com",
        ),
        "local_tmp_fs": {"base_dir": "/tmp/dagster_sales_reports"},
        "io_manager": fs_io_manager,
    },
)
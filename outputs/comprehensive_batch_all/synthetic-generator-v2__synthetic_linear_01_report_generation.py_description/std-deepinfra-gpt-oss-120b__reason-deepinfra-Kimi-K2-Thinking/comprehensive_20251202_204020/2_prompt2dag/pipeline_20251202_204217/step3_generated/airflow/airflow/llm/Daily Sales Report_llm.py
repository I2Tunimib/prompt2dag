# Generated by Airflow DAG generator on 2024-06-28
# DAG: Daily Sales Report
# Description: Generates daily sales reports by querying PostgreSQL, converting the result to CSV,
# creating a PDF chart, and emailing the final report to management.

from datetime import datetime, timedelta
from airflow import DAG
from airflow.utils import timezone
from airflow.providers.common.sql.operators.sql import SQLExecuteQueryOperator
from airflow.operators.python import PythonOperator
from airflow.exceptions import AirflowException

import csv
import os
import smtplib
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from email import encoders

import pandas as pd
import matplotlib.pyplot as plt
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas


# ----------------------------------------------------------------------
# Helper functions
# ----------------------------------------------------------------------


def transform_to_csv(**context):
    """
    Transform the query result (list of dicts) into a CSV file.
    The query result is retrieved from XCom pushed by the previous task.
    """
    try:
        # Pull query result from XCom
        query_result = context['ti'].xcom_pull(task_ids='query_sales_data')
        if not query_result:
            raise AirflowException("No data returned from query_sales_data task.")

        # Ensure the temporary directory exists
        csv_path = context['csv_path']
        os.makedirs(os.path.dirname(csv_path), exist_ok=True)

        # Write CSV using pandas for simplicity
        df = pd.DataFrame(query_result)
        df.to_csv(csv_path, index=False)
        # Push CSV path to XCom for downstream tasks (optional)
        context['ti'].xcom_push(key='csv_path', value=csv_path)
    except Exception as exc:
        raise AirflowException(f"Failed to transform data to CSV: {exc}") from exc


def generate_pdf_chart(**context):
    """
    Generate a PDF report containing a chart based on the CSV data.
    """
    try:
        csv_path = context['csv_path']
        pdf_path = context['pdf_path']

        if not os.path.isfile(csv_path):
            raise AirflowException(f"CSV file not found at {csv_path}")

        # Load data
        df = pd.read_csv(csv_path)

        # Example chart: total sales per product
        if 'product' not in df.columns or 'amount' not in df.columns:
            raise AirflowException("CSV does not contain required columns 'product' and 'amount'.")

        chart_data = df.groupby('product')['amount'].sum().reset_index()

        # Plot chart
        plt.figure(figsize=(8, 6))
        plt.bar(chart_data['product'], chart_data['amount'], color='skyblue')
        plt.title('Total Sales per Product')
        plt.xlabel('Product')
        plt.ylabel('Sales Amount')
        plt.tight_layout()
        chart_image_path = '/tmp/sales_chart.png'
        plt.savefig(chart_image_path)
        plt.close()

        # Create PDF using ReportLab
        os.makedirs(os.path.dirname(pdf_path), exist_ok=True)
        c = canvas.Canvas(pdf_path, pagesize=letter)
        width, height = letter

        # Add title
        c.setFont("Helvetica-Bold", 16)
        c.drawCentredString(width / 2, height - 50, "Daily Sales Report")

        # Insert chart image
        c.drawImage(chart_image_path, 50, height - 400, width=500, preserveAspectRatio=True, mask='auto')

        c.showPage()
        c.save()

        # Cleanup temporary chart image
        if os.path.isfile(chart_image_path):
            os.remove(chart_image_path)

        # Push PDF path to XCom for downstream tasks (optional)
        context['ti'].xcom_push(key='pdf_path', value=pdf_path)
    except Exception as exc:
        raise AirflowException(f"Failed to generate PDF chart: {exc}") from exc


def email_sales_report(**context):
    """
    Email the generated PDF report to management using the configured SMTP server.
    """
    try:
        pdf_path = context['pdf_path']
        if not os.path.isfile(pdf_path):
            raise AirflowException(f"PDF report not found at {pdf_path}")

        # Email configuration (could also be stored in Airflow Variables or Connections)
        smtp_conn_id = 'smtp_email_server'
        # Retrieve SMTP connection details from Airflow's connection system
        from airflow.hooks.base import BaseHook
        conn = BaseHook.get_connection(smtp_conn_id)

        smtp_host = conn.host
        smtp_port = conn.port or 587
        smtp_user = conn.login
        smtp_password = conn.password
        use_tls = conn.extra_dejson.get('use_tls', True)

        sender = conn.extra_dejson.get('sender', smtp_user)
        recipients = conn.extra_dejson.get('recipients')
        if not recipients:
            raise AirflowException("Recipient list not defined in SMTP connection extras.")

        # Build email
        message = MIMEMultipart()
        message['From'] = sender
        message['To'] = ', '.join(recipients)
        message['Subject'] = f"Daily Sales Report - {datetime.utcnow().strftime('%Y-%m-%d')}"

        # Attach PDF
        with open(pdf_path, 'rb') as f:
            part = MIMEApplication(f.read(), _subtype="pdf")
            part.add_header('Content-Disposition', 'attachment', filename=os.path.basename(pdf_path))
            message.attach(part)

        # Send email
        with smtplib.SMTP(smtp_host, smtp_port) as server:
            if use_tls:
                server.starttls()
            if smtp_user and smtp_password:
                server.login(smtp_user, smtp_password)
            server.sendmail(sender, recipients, message.as_string())
    except Exception as exc:
        raise AirflowException(f"Failed to send email report: {exc}") from exc


# ----------------------------------------------------------------------
# DAG definition
# ----------------------------------------------------------------------


default_args = {
    'owner': 'airflow',
    'retries': 2,
    'retry_delay': timedelta(minutes=5),
    'email_on_failure': False,
    'email_on_retry': False,
}

with DAG(
    dag_id='daily_sales_report',
    description='Generates daily sales reports by querying PostgreSQL, converting the result to CSV, creating a PDF chart, and emailing the final report to management.',
    schedule_interval='@daily',
    start_date=datetime(2024, 1, 1, tzinfo=timezone.utc),
    catchup=False,
    default_args=default_args,
    tags=['sales', 'reporting'],
) as dag:

    # Task 1: Query sales data from PostgreSQL
    query_sales_data = SQLExecuteQueryOperator(
        task_id='query_sales_data',
        conn_id='postgres_sales_db',
        sql="""
            SELECT *
            FROM sales
            WHERE sale_date = CURRENT_DATE;
        """,
        do_xcom_push=True,
        retries=2,
    )

    # Task 2: Transform query result to CSV
    transform_sales_to_csv = PythonOperator(
        task_id='transform_to_csv',
        python_callable=transform_to_csv,
        op_kwargs={'csv_path': '/tmp/sales_report.csv'},
        retries=2,
    )

    # Task 3: Generate PDF chart from CSV
    generate_pdf_chart_task = PythonOperator(
        task_id='generate_pdf_chart',
        python_callable=generate_pdf_chart,
        op_kwargs={
            'csv_path': '/tmp/sales_report.csv',
            'pdf_path': '/tmp/sales_report.pdf',
        },
        retries=2,
    )

    # Task 4: Email the final PDF report
    email_sales_report_task = PythonOperator(
        task_id='email_sales_report',
        python_callable=email_sales_report,
        op_kwargs={'pdf_path': '/tmp/sales_report.pdf'},
        retries=2,
    )

    # Define sequential dependencies
    query_sales_data >> transform_sales_to_csv >> generate_pdf_chart_task >> email_sales_report_task

# End of DAG definition
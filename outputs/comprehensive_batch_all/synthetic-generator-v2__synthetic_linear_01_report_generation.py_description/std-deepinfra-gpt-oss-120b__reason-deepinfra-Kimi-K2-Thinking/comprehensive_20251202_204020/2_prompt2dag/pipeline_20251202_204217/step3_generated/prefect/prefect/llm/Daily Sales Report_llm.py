# Generated by Prefect Pipeline Generator on 2024-06-28
# Pipeline: Daily Sales Report
# Prefect version: 2.14.0

import os
import io
import datetime
import smtplib
import ssl
from email.message import EmailMessage

import pandas as pd
import matplotlib.pyplot as plt
import psycopg2
from psycopg2.extras import RealDictCursor

from prefect import flow, task, get_run_logger
from prefect.task_runners import SequentialTaskRunner
from prefect.blocks.system import Secret
from prefect.filesystems import LocalFileSystem
from prefect.deployments import DeploymentSpec
from prefect.orion.schemas.schedules import CronSchedule

# -------------------------------------------------------------------------
# Block names (must match the names configured in Prefect UI)
POSTGRES_SECRET_BLOCK = "postgres_sales_db"
LOCAL_FS_BLOCK = "local_tmp_fs"
SMTP_SECRET_BLOCK = "smtp_email_server"

# -------------------------------------------------------------------------
# Helper functions
def _load_secret(block_name: str) -> str:
    """Load a secret value from a Prefect Secret block."""
    logger = get_run_logger()
    try:
        secret_block = Secret.load(block_name)
        secret_value = secret_block.get()
        logger.debug(f"Loaded secret from block '{block_name}'.")
        return secret_value
    except Exception as exc:
        logger.error(f"Failed to load secret block '{block_name}': {exc}")
        raise


def _load_filesystem(block_name: str) -> LocalFileSystem:
    """Load a LocalFileSystem block."""
    logger = get_run_logger()
    try:
        fs_block = LocalFileSystem.load(block_name)
        logger.debug(f"Loaded filesystem block '{block_name}'.")
        return fs_block
    except Exception as exc:
        logger.error(f"Failed to load filesystem block '{block_name}': {exc}")
        raise


# -------------------------------------------------------------------------
# Tasks
@task(retries=2, retry_delay_seconds=60, name="Query Sales Data")
def query_sales_data() -> list[dict]:
    """
    Query the PostgreSQL sales database for today's sales records.

    Returns:
        A list of dictionaries, each representing a row from the query.
    """
    logger = get_run_logger()
    logger.info("Starting sales data query.")

    dsn = _load_secret(POSTGRES_SECRET_BLOCK)

    query = """
        SELECT *
        FROM sales
        WHERE sale_date = CURRENT_DATE;
    """

    try:
        with psycopg2.connect(dsn) as conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute(query)
                rows = cur.fetchall()
                logger.info(f"Fetched {len(rows)} rows for today's sales.")
                return rows
    except Exception as exc:
        logger.error(f"Error querying sales data: {exc}")
        raise


@task(retries=2, retry_delay_seconds=60, name="Transform Sales Data to CSV")
def transform_to_csv(sales_data: list[dict]) -> str:
    """
    Convert sales data to a CSV file stored on the local temporary filesystem.

    Args:
        sales_data: List of dictionaries representing sales rows.

    Returns:
        The path (relative to the filesystem block) of the generated CSV file.
    """
    logger = get_run_logger()
    logger.info("Transforming sales data to CSV.")

    if not sales_data:
        logger.warning("No sales data received; creating empty CSV.")
        df = pd.DataFrame()
    else:
        df = pd.DataFrame(sales_data)

    today_str = datetime.date.today().isoformat()
    csv_filename = f"sales_{today_str}.csv"

    fs = _load_filesystem(LOCAL_FS_BLOCK)

    try:
        # Write CSV to an inâ€‘memory buffer first
        csv_buffer = io.StringIO()
        df.to_csv(csv_buffer, index=False)
        csv_bytes = csv_buffer.getvalue().encode("utf-8")

        # Use the filesystem block to write the file
        fs.write_path(csv_filename, csv_bytes)
        logger.info(f"CSV written to temporary filesystem at '{csv_filename}'.")
        return csv_filename
    except Exception as exc:
        logger.error(f"Failed to write CSV file: {exc}")
        raise


@task(retries=2, retry_delay_seconds=60, name="Generate PDF Chart")
def generate_pdf_chart(csv_path: str) -> str:
    """
    Generate a PDF chart from the CSV sales data.

    Args:
        csv_path: Path (relative to the filesystem block) of the CSV file.

    Returns:
        The path (relative to the filesystem block) of the generated PDF file.
    """
    logger = get_run_logger()
    logger.info("Generating PDF chart from CSV data.")

    fs = _load_filesystem(LOCAL_FS_BLOCK)

    try:
        # Read CSV content via the filesystem block
        csv_bytes = fs.read_path(csv_path)
        df = pd.read_csv(io.BytesIO(csv_bytes))
    except Exception as exc:
        logger.error(f"Failed to read CSV from '{csv_path}': {exc}")
        raise

    if df.empty:
        logger.warning("CSV data is empty; generating placeholder chart.")
        fig, ax = plt.subplots()
        ax.text(0.5, 0.5, "No sales data for today", ha="center", va="center")
    else:
        # Example chart: total sales per product
        if "product_name" not in df.columns or "amount" not in df.columns:
            logger.error("CSV does not contain required columns 'product_name' and 'amount'.")
            raise ValueError("Missing required columns for chart generation.")
        summary = df.groupby("product_name")["amount"].sum().reset_index()
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.bar(summary["product_name"], summary["amount"])
        ax.set_xlabel("Product")
        ax.set_ylabel("Total Sales Amount")
        ax.set_title("Today's Sales by Product")
        plt.xticks(rotation=45, ha="right")
        plt.tight_layout()

    pdf_buffer = io.BytesIO()
    try:
        fig.savefig(pdf_buffer, format="pdf")
        plt.close(fig)
        pdf_bytes = pdf_buffer.getvalue()
    except Exception as exc:
        logger.error(f"Failed to generate PDF chart: {exc}")
        raise

    today_str = datetime.date.today().isoformat()
    pdf_filename = f"sales_chart_{today_str}.pdf"

    try:
        fs.write_path(pdf_filename, pdf_bytes)
        logger.info(f"PDF chart written to temporary filesystem at '{pdf_filename}'.")
        return pdf_filename
    except Exception as exc:
        logger.error(f"Failed to write PDF file: {exc}")
        raise


@task(retries=2, retry_delay_seconds=60, name="Email Sales Report")
def email_sales_report(csv_path: str, pdf_path: str) -> None:
    """
    Email the sales report (CSV and PDF) to management.

    Args:
        csv_path: Path (relative to the filesystem block) of the CSV file.
        pdf_path: Path (relative to the filesystem block) of the PDF chart.
    """
    logger = get_run_logger()
    logger.info("Preparing to email sales report.")

    # Load SMTP credentials from secret block (expected JSON)
    smtp_secret = _load_secret(SMTP_SECRET_BLOCK)
    try:
        smtp_cfg = eval(smtp_secret)  # Expected format: {"host": "...", "port": 587, "user": "...", "password": "...", "from": "...", "to": ["..."]}
    except Exception as exc:
        logger.error(f"SMTP secret is not a valid dict: {exc}")
        raise

    required_keys = {"host", "port", "user", "password", "from", "to"}
    if not required_keys.issubset(smtp_cfg):
        missing = required_keys - smtp_cfg.keys()
        logger.error(f"SMTP configuration missing keys: {missing}")
        raise ValueError(f"Missing SMTP configuration keys: {missing}")

    fs = _load_filesystem(LOCAL_FS_BLOCK)

    try:
        csv_bytes = fs.read_path(csv_path)
        pdf_bytes = fs.read_path(pdf_path)
    except Exception as exc:
        logger.error(f"Failed to read attachment files: {exc}")
        raise

    message = EmailMessage()
    message["Subject"] = f"Daily Sales Report - {datetime.date.today().isoformat()}"
    message["From"] = smtp_cfg["from"]
    message["To"] = ", ".join(smtp_cfg["to"])
    message.set_content("Please find attached the daily sales CSV and PDF chart.")

    message.add_attachment(csv_bytes, maintype="text", subtype="csv", filename=os.path.basename(csv_path))
    message.add_attachment(pdf_bytes, maintype="application", subtype="pdf", filename=os.path.basename(pdf_path))

    context = ssl.create_default_context()
    try:
        with smtplib.SMTP(smtp_cfg["host"], smtp_cfg["port"]) as server:
            server.starttls(context=context)
            server.login(smtp_cfg["user"], smtp_cfg["password"])
            server.send_message(message)
        logger.info("Sales report email sent successfully.")
    except Exception as exc:
        logger.error(f"Failed to send email: {exc}")
        raise


# -------------------------------------------------------------------------
# Flow definition
@flow(
    name="Daily Sales Report",
    description="Generates daily sales reports by querying PostgreSQL, converting the result to CSV, creating a PDF chart, and emailing the final report to management.",
    task_runner=SequentialTaskRunner(),
)
def daily_sales_report() -> None:
    """
    Orchestrates the daily sales reporting pipeline.
    """
    logger = get_run_logger()
    logger.info("Starting Daily Sales Report flow.")

    sales_data = query_sales_data()
    csv_path = transform_to_csv(sales_data)
    pdf_path = generate_pdf_chart(csv_path)
    email_sales_report(csv_path, pdf_path)

    logger.info("Daily Sales Report flow completed.")


# -------------------------------------------------------------------------
# Deployment specification
DeploymentSpec(
    name="daily_sales_report_deployment",
    flow=daily_sales_report,
    schedule=CronSchedule(
        cron="0 0 * * *",  # @daily at 00:00 UTC
        timezone="UTC",
        catchup=False,
    ),
    tags=[],
    work_pool_name="default-agent-pool",
    task_runner=SequentialTaskRunner(),
)


# -------------------------------------------------------------------------
# Enable local execution
if __name__ == "__main__":
    daily_sales_report()
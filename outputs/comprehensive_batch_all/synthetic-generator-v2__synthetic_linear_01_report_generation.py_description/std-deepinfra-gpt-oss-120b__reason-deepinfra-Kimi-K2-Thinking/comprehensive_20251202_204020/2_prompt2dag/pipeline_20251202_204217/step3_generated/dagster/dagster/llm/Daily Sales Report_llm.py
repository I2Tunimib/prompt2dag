# Generated by Dagster Code Generator
# Date: 2024-06-13
# Dagster version: 1.5.0

from __future__ import annotations

import csv
import io
import os
import smtplib
from email.message import EmailMessage
from typing import List, Dict

import pandas as pd
import matplotlib.pyplot as plt
from dagster import (
    In,
    Out,
    RetryPolicy,
    ResourceDefinition,
    String,
    asset,
    job,
    op,
    fs_io_manager,
    in_process_executor,
    schedule,
    ConfigurableResource,
    InitResourceContext,
    Output,
    Nothing,
)

# ----------------------------------------------------------------------
# Resource definitions
# ----------------------------------------------------------------------


class PostgresSalesDBResource(ConfigurableResource):
    """Resource for connecting to the PostgreSQL sales database."""

    host: str
    port: int
    database: str
    user: str
    password: str

    def get_connection(self):
        """Create a new psycopg2 connection."""
        import psycopg2

        return psycopg2.connect(
            host=self.host,
            port=self.port,
            dbname=self.database,
            user=self.user,
            password=self.password,
        )


class SMTPEmailServerResource(ConfigurableResource):
    """Resource for sending email via an SMTP server."""

    host: str
    port: int
    username: str
    password: str
    use_tls: bool = True

    def get_client(self) -> smtplib.SMTP:
        client = smtplib.SMTP(self.host, self.port)
        client.ehlo()
        if self.use_tls:
            client.starttls()
        client.login(self.username, self.password)
        return client


# ----------------------------------------------------------------------
# Ops
# ----------------------------------------------------------------------


@op(
    name="query_sales_data",
    description="Query daily sales data from the PostgreSQL sales database.",
    out=Out(List[Dict[str, any]], description="List of sales records."),
    retry_policy=RetryPolicy(max_retries=2),
    required_resource_keys={"postgres_sales_db"},
)
def query_sales_data(context: InitResourceContext) -> List[Dict[str, any]]:
    """Execute a SQL query to retrieve today's sales data."""
    sql = """
        SELECT
            order_id,
            product_id,
            quantity,
            total_price,
            order_timestamp::date AS order_date
        FROM sales
        WHERE order_timestamp::date = CURRENT_DATE;
    """
    conn = context.resources.postgres_sales_db.get_connection()
    try:
        with conn.cursor() as cur:
            cur.execute(sql)
            columns = [desc[0] for desc in cur.description]
            rows = cur.fetchall()
            records = [dict(zip(columns, row)) for row in rows]
            context.log.info(f"Fetched {len(records)} sales records.")
            return records
    finally:
        conn.close()


@op(
    name="transform_to_csv",
    description="Transform sales data into a CSV file stored on the local temporary filesystem.",
    ins={"sales_data": In(List[Dict[str, any]])},
    out=Out(str, description="Path to the generated CSV file."),
    retry_policy=RetryPolicy(max_retries=2),
    required_resource_keys={"local_tmp_fs"},
)
def transform_to_csv(context: InitResourceContext, sales_data: List[Dict[str, any]]) -> str:
    """Write the list of sales dictionaries to a CSV file."""
    if not sales_data:
        context.log.warning("No sales data received; creating empty CSV.")
    csv_path = os.path.join(context.resources.local_tmp_fs.base_dir, "daily_sales.csv")
    fieldnames = sales_data[0].keys() if sales_data else ["order_id", "product_id", "quantity", "total_price", "order_date"]
    with open(csv_path, mode="w", newline="", encoding="utf-8") as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for row in sales_data:
            writer.writerow(row)
    context.log.info(f"CSV written to {csv_path}")
    return csv_path


@op(
    name="generate_pdf_chart",
    description="Generate a PDF chart from the CSV sales data.",
    ins={"csv_path": In(str)},
    out=Out(str, description="Path to the generated PDF file."),
    retry_policy=RetryPolicy(max_retries=2),
    required_resource_keys={"local_tmp_fs"},
)
def generate_pdf_chart(context: InitResourceContext, csv_path: str) -> str:
    """Read the CSV, create a bar chart of total sales per product, and save as PDF."""
    df = pd.read_csv(csv_path)
    if df.empty:
        context.log.warning("CSV is empty; generating placeholder PDF.")
        fig, ax = plt.subplots()
        ax.text(0.5, 0.5, "No sales data for today", ha="center", va="center")
    else:
        sales_by_product = df.groupby("product_id")["total_price"].sum().reset_index()
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.bar(sales_by_product["product_id"].astype(str), sales_by_product["total_price"])
        ax.set_xlabel("Product ID")
        ax.set_ylabel("Total Sales ($)")
        ax.set_title("Daily Sales by Product")
        plt.xticks(rotation=45, ha="right")
    pdf_path = os.path.join(context.resources.local_tmp_fs.base_dir, "daily_sales_report.pdf")
    fig.tight_layout()
    fig.savefig(pdf_path, format="pdf")
    plt.close(fig)
    context.log.info(f"PDF chart saved to {pdf_path}")
    return pdf_path


@op(
    name="email_sales_report",
    description="Email the PDF sales report to management.",
    ins={"pdf_path": In(str)},
    out=Out(Nothing),
    retry_policy=RetryPolicy(max_retries=2),
    required_resource_keys={"smtp_email_server"},
)
def email_sales_report(context: InitResourceContext, pdf_path: str) -> Nothing:
    """Compose an email with the PDF attached and send it via SMTP."""
    with open(pdf_path, "rb") as f:
        pdf_bytes = f.read()

    msg = EmailMessage()
    msg["Subject"] = "Daily Sales Report"
    msg["From"] = context.resources.smtp_email_server.username
    msg["To"] = "management@example.com"
    msg.set_content("Please find attached the daily sales report.")
    msg.add_attachment(
        pdf_bytes,
        maintype="application",
        subtype="pdf",
        filename=os.path.basename(pdf_path),
    )

    client = context.resources.smtp_email_server.get_client()
    try:
        client.send_message(msg)
        context.log.info("Sales report email sent to management.")
    finally:
        client.quit()
    return Nothing


# ----------------------------------------------------------------------
# Job definition
# ----------------------------------------------------------------------


@job(
    name="daily_sales_report",
    description=(
        "Generates daily sales reports by querying PostgreSQL, converting the result to CSV, "
        "creating a PDF chart, and emailing the final report to management."
    ),
    executor_def=in_process_executor,
    resource_defs={
        "postgres_sales_db": PostgresSalesDBResource,
        "local_tmp_fs": fs_io_manager,
        "smtp_email_server": SMTPEmailServerResource,
    },
    config={
        "resources": {
            "postgres_sales_db": {
                "config": {
                    "host": "postgres.example.com",
                    "port": 5432,
                    "database": "salesdb",
                    "user": "sales_user",
                    "password": {"env": "POSTGRES_PASSWORD"},
                }
            },
            "smtp_email_server": {
                "config": {
                    "host": "smtp.example.com",
                    "port": 587,
                    "username": "no-reply@example.com",
                    "password": {"env": "SMTP_PASSWORD"},
                    "use_tls": True,
                }
            },
            "local_tmp_fs": {
                "config": {"base_dir": "/tmp/dagster_sales_reports"}
            },
        }
    },
)
def daily_sales_report_job():
    """Dagster job orchestrating the daily sales report pipeline."""
    sales_data = query_sales_data()
    csv_path = transform_to_csv(sales_data)
    pdf_path = generate_pdf_chart(csv_path)
    email_sales_report(pdf_path)


# ----------------------------------------------------------------------
# Schedule definition
# ----------------------------------------------------------------------


@schedule(
    cron_schedule="@daily",
    job=daily_sales_report_job,
    execution_timezone="UTC",
    default_status="RUNNING",
    description="Runs the daily sales report job each day at midnight UTC.",
    tags={"catchup": "false"},
)
def daily_sales_report_schedule():
    """Schedule that triggers the daily_sales_report_job every day at midnight UTC."""
    return {}


# ----------------------------------------------------------------------
# End of file
# ----------------------------------------------------------------------
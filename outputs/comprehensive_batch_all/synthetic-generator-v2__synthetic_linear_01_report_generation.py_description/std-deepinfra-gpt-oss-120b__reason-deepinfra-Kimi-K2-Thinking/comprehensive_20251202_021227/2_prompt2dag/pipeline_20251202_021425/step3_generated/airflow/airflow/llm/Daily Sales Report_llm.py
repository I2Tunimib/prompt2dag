# Generated by Airflow DAG Generator on 2024-06-13
"""
Daily Sales Report DAG

This DAG runs daily at UTC midnight and performs the following steps:
1. Query sales data from a PostgreSQL database.
2. Transform the query result into a CSV file.
3. Generate a PDF chart from the CSV data.
4. Email the CSV and PDF report to stakeholders.

All tasks have retry logic and basic error handling.
"""

from __future__ import annotations

import csv
import os
import smtplib
import tempfile
from datetime import timedelta
from email.message import EmailMessage
from pathlib import Path
from typing import List, Dict

import matplotlib.pyplot as plt
import pandas as pd
from airflow import DAG
from airflow.exceptions import AirflowException
from airflow.providers.common.sql.operators.sql import SQLExecuteQueryOperator
from airflow.operators.python import PythonOperator
from airflow.utils.dates import days_ago

# -------------------------------------------------------------------------
# Default arguments applied to all tasks
# -------------------------------------------------------------------------
DEFAULT_ARGS = {
    "owner": "airflow",
    "retries": 2,
    "retry_delay": timedelta(minutes=5),
    "email_on_failure": False,
    "email_on_retry": False,
}

# -------------------------------------------------------------------------
# DAG definition
# -------------------------------------------------------------------------
with DAG(
    dag_id="daily_sales_report",
    description="Generate daily sales reports and email them.",
    schedule_interval="@daily",
    start_date=days_ago(1),
    catchup=False,
    default_args=DEFAULT_ARGS,
    tags=["sales", "reporting"],
    max_active_runs=1,
) as dag:
    # ---------------------------------------------------------------------
    # Task 1: Query sales data from PostgreSQL
    # ---------------------------------------------------------------------
    query_sales_data = SQLExecuteQueryOperator(
        task_id="query_sales_data",
        conn_id="postgres_sales_db",
        sql="""
            SELECT *
            FROM sales
            WHERE sale_date = CURRENT_DATE
        """,
        do_xcom_push=True,
    )

    # ---------------------------------------------------------------------
    # Task 2: Transform query result to CSV
    # ---------------------------------------------------------------------
    def _transform_to_csv(**context) -> str:
        """
        Pulls query results from XCom, writes them to a CSV file,
        and returns the absolute path of the generated file.
        """
        ti = context["ti"]
        rows: List[Dict] = ti.xcom_pull(task_ids="query_sales_data")
        if not rows:
            raise AirflowException("No data returned from query_sales_data task.")

        # Use a temporary directory provided by the local_tmp_fs connection
        tmp_dir = Path(tempfile.gettempdir())
        csv_path = tmp_dir / f"sales_report_{ti.execution_date.strftime('%Y%m%d')}.csv"

        try:
            # Convert list of dicts to pandas DataFrame for easier CSV export
            df = pd.DataFrame(rows)
            df.to_csv(csv_path, index=False, quoting=csv.QUOTE_NONNUMERIC)
        except Exception as exc:
            raise AirflowException(f"Failed to write CSV: {exc}") from exc

        # Push the CSV path to XCom for downstream tasks
        ti.xcom_push(key="csv_path", value=str(csv_path))
        return str(csv_path)

    transform_to_csv = PythonOperator(
        task_id="transform_to_csv",
        python_callable=_transform_to_csv,
        provide_context=True,
    )

    # ---------------------------------------------------------------------
    # Task 3: Generate PDF chart from CSV data
    # ---------------------------------------------------------------------
    def _generate_pdf_chart(**context) -> str:
        """
        Reads the CSV file generated by the previous task,
        creates a simple bar chart, and saves it as a PDF.
        Returns the absolute path of the PDF file.
        """
        ti = context["ti"]
        csv_path: str = ti.xcom_pull(key="csv_path", task_ids="transform_to_csv")
        if not csv_path or not os.path.isfile(csv_path):
            raise AirflowException("CSV file not found for PDF generation.")

        pdf_path = Path(csv_path).with_suffix(".pdf")

        try:
            df = pd.read_csv(csv_path)
            # Example: assume the CSV has columns 'product' and 'amount'
            if "product" not in df.columns or "amount" not in df.columns:
                raise AirflowException("CSV missing required columns for chart.")

            plt.figure(figsize=(10, 6))
            df.groupby("product")["amount"].sum().plot(kind="bar")
            plt.title("Daily Sales by Product")
            plt.xlabel("Product")
            plt.ylabel("Total Sales")
            plt.tight_layout()
            plt.savefig(pdf_path, format="pdf")
            plt.close()
        except Exception as exc:
            raise AirflowException(f"Failed to generate PDF chart: {exc}") from exc

        ti.xcom_push(key="pdf_path", value=str(pdf_path))
        return str(pdf_path)

    generate_pdf_chart = PythonOperator(
        task_id="generate_pdf_chart",
        python_callable=_generate_pdf_chart,
        provide_context=True,
    )

    # ---------------------------------------------------------------------
    # Task 4: Email the sales report
    # ---------------------------------------------------------------------
    def _email_sales_report(**context) -> None:
        """
        Emails the CSV and PDF report as attachments using the
        SMTP connection defined in Airflow.
        """
        ti = context["ti"]
        csv_path: str = ti.xcom_pull(key="csv_path", task_ids="transform_to_csv")
        pdf_path: str = ti.xcom_pull(key="pdf_path", task_ids="generate_pdf_chart")

        if not csv_path or not pdf_path:
            raise AirflowException("Required report files are missing for email.")

        # Retrieve SMTP connection details from Airflow
        from airflow.hooks.base import BaseHook

        conn = BaseHook.get_connection("email_smtp_service")
        if not conn:
            raise AirflowException("SMTP connection 'email_smtp_service' not found.")

        smtp_host = conn.host
        smtp_port = conn.port or 587
        smtp_user = conn.login
        smtp_password = conn.password
        use_tls = conn.extra_dejson.get("use_tls", True)

        # Build email
        msg = EmailMessage()
        msg["Subject"] = f"Daily Sales Report - {ti.execution_date.strftime('%Y-%m-%d')}"
        msg["From"] = smtp_user
        msg["To"] = "sales-team@example.com"  # Replace with actual recipients
        msg.set_content(
            "Please find attached the daily sales CSV report and the PDF chart."
        )

        # Attach CSV
        with open(csv_path, "rb") as f:
            msg.add_attachment(
                f.read(),
                maintype="text",
                subtype="csv",
                filename=os.path.basename(csv_path),
            )

        # Attach PDF
        with open(pdf_path, "rb") as f:
            msg.add_attachment(
                f.read(),
                maintype="application",
                subtype="pdf",
                filename=os.path.basename(pdf_path),
            )

        # Send email
        try:
            with smtplib.SMTP(smtp_host, smtp_port) as server:
                if use_tls:
                    server.starttls()
                if smtp_user and smtp_password:
                    server.login(smtp_user, smtp_password)
                server.send_message(msg)
        except Exception as exc:
            raise AirflowException(f"Failed to send email: {exc}") from exc

    email_sales_report = PythonOperator(
        task_id="email_sales_report",
        python_callable=_email_sales_report,
        provide_context=True,
    )

    # ---------------------------------------------------------------------
    # Set task dependencies (sequential linear pipeline)
    # ---------------------------------------------------------------------
    query_sales_data >> transform_to_csv >> generate_pdf_chart >> email_sales_report
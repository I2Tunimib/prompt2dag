# Generated by Dagster Pipeline Generator
# Date: 2024-11-04
# Pipeline: Daily Sales Report
# Description: Sequential linear pipeline that generates daily sales reports by querying PostgreSQL,
# converting to CSV, creating a PDF chart, and emailing the report.

from __future__ import annotations

import os
import uuid
import csv
from typing import Any, Dict, List

from dagster import (
    op,
    job,
    In,
    Out,
    RetryPolicy,
    ConfigurableResource,
    fs_io_manager,
    ScheduleDefinition,
    ScheduleStatus,
    Definitions,
    in_process_executor,
)


class PostgresSalesDBResource(ConfigurableResource):
    """Resource for connecting to the PostgreSQL sales database."""

    username: str
    password: str
    host: str
    port: int
    database: str

    def get_connection(self) -> Any:
        """Return a database connection.

        In a production setting this would create a psycopg2 or asyncpg connection.
        """
        # Placeholder implementation – replace with real connection logic.
        return None


class EmailSMTPServiceResource(ConfigurableResource):
    """Resource for sending emails via an SMTP server."""

    smtp_server: str
    smtp_port: int
    username: str
    password: str

    def send_email(self, subject: str, body: str, attachments: List[str]) -> None:
        """Send an email with the given subject, body, and file attachments.

        In a production setting this would use smtplib or a third‑party email library.
        """
        # Placeholder implementation – replace with real email‑sending logic.
        print(f"Sending email: {subject}")
        for attachment in attachments:
            print(f"  attachment: {attachment}")


@op(
    name="query_sales_data",
    description="Query daily sales data from PostgreSQL.",
    out=Out(dict, description="Raw sales data."),
    retry_policy=RetryPolicy(max_retries=2),
)
def query_sales_data(context) -> Dict[str, Any]:
    """Fetch sales data from the PostgreSQL sales database."""
    db: PostgresSalesDBResource = context.resources.postgres_sales_db
    # Placeholder query – replace with actual SQL execution.
    context.log.info("Querying sales data from PostgreSQL.")
    data = {"sales": [{"date": "2024-01-01", "amount": 1000}]}
    return data


@op(
    name="transform_to_csv",
    description="Convert sales data to a CSV file.",
    ins={"sales_data": In(dict)},
    out=Out(str, description="Path to the generated CSV file."),
    retry_policy=RetryPolicy(max_retries=2),
)
def transform_to_csv(context, sales_data: Dict[str, Any]) -> str:
    """Write sales data to a CSV file in the temporary filesystem."""
    tmp_dir: str = context.resources.local_tmp_fs.base_dir
    filename = f"sales_{uuid.uuid4().hex}.csv"
    csv_path = os.path.join(tmp_dir, filename)

    context.log.info(f"Writing CSV to {csv_path}")
    with open(csv_path, "w", newline="") as csv_file:
        writer = csv.DictWriter(csv_file, fieldnames=["date", "amount"])
        writer.writeheader()
        for row in sales_data.get("sales", []):
            writer.writerow(row)

    return csv_path


@op(
    name="generate_pdf_chart",
    description="Generate a PDF chart from CSV sales data.",
    ins={"csv_path": In(str)},
    out=Out(str, description="Path to the generated PDF file."),
    retry_policy=RetryPolicy(max_retries=2),
)
def generate_pdf_chart(context, csv_path: str) -> str:
    """Create a PDF chart from the CSV file.

    In a real implementation this would read the CSV, generate a chart with matplotlib,
    and embed it in a PDF using ReportLab or a similar library.
    """
    pdf_path = os.path.join(os.path.dirname(csv_path), f"{uuid.uuid4().hex}.pdf")
    context.log.info(f"Generating PDF chart at {pdf_path}")

    # Placeholder PDF content.
    with open(pdf_path, "wb") as pdf_file:
        pdf_file.write(b"%PDF-1.4\n%Placeholder PDF content\n%%EOF")

    return pdf_path


@op(
    name="email_sales_report",
    description="Email the PDF sales report.",
    ins={"pdf_path": In(str)},
    out=Out(None),
    retry_policy=RetryPolicy(max_retries=2),
)
def email_sales_report(context, pdf_path: str) -> None:
    """Send the PDF report via email."""
    email_service: EmailSMTPServiceResource = context.resources.email_smtp_service
    subject = "Daily Sales Report"
    body = "Please find attached the daily sales report."
    context.log.info(f"Sending email with attachment {pdf_path}")
    email_service.send_email(subject, body, [pdf_path])


@job(
    name="daily_sales_report",
    description=(
        "Sequential linear pipeline that generates daily sales reports by querying PostgreSQL, "
        "converting to CSV, creating a PDF chart, and emailing the report."
    ),
    resource_defs={
        "postgres_sales_db": PostgresSalesDBResource,
        "local_tmp_fs": fs_io_manager,
        "email_smtp_service": EmailSMTPServiceResource,
    },
    executor_def=in_process_executor,
)
def daily_sales_report():
    """Orchestrates the daily sales reporting workflow."""
    sales_data = query_sales_data()
    csv_path = transform_to_csv(sales_data)
    pdf_path = generate_pdf_chart(csv_path)
    email_sales_report(pdf_path)


daily_sales_schedule = ScheduleDefinition(
    job=daily_sales_report,
    cron_schedule="@daily",
    execution_timezone="UTC",
    default_status=ScheduleStatus.RUNNING,
    description="Run the daily sales report at midnight UTC.",
    catchup=False,
)


defs = Definitions(
    jobs=[daily_sales_report],
    schedules=[daily_sales_schedule],
    resources={
        "postgres_sales_db": PostgresSalesDBResource.configure_at_launch(),
        "local_tmp_fs": fs_io_manager,
        "email_smtp_service": EmailSMTPServiceResource.configure_at_launch(),
    },
)
# Generated by Dagster Code Generator
# Date: 2023-10-05
# Dagster Version: 1.5.0

from dagster import (
    job,
    op,
    Out,
    In,
    RetryPolicy,
    resource,
    fs_io_manager,
    in_process_executor,
    schedule,
)
from dagster.utils import file_relative_path
import pandas as pd
import psycopg2
import matplotlib.pyplot as plt
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication


@resource
def postgres_default(context):
    """Resource for connecting to the PostgreSQL database."""
    conn = psycopg2.connect(
        dbname=context.resource_config["dbname"],
        user=context.resource_config["user"],
        password=context.resource_config["password"],
        host=context.resource_config["host"],
        port=context.resource_config["port"],
    )
    return conn


@resource
def email_system(context):
    """Resource for sending emails."""
    return smtplib.SMTP(context.resource_config["smtp_server"], context.resource_config["smtp_port"])


@op(
    required_resource_keys={"postgres_default"},
    out={"sales_data": Out(dagster_type=pd.DataFrame)},
    retry_policy=RetryPolicy(max_retries=2),
)
def query_sales_data(context):
    """Query sales data from the PostgreSQL database."""
    conn = context.resources.postgres_default
    query = "SELECT * FROM sales_data WHERE date = CURRENT_DATE"
    sales_data = pd.read_sql(query, conn)
    return sales_data


@op(
    ins={"sales_data": In(dagster_type=pd.DataFrame)},
    out={"csv_file_path": Out(dagster_type=str)},
    retry_policy=RetryPolicy(max_retries=2),
)
def transform_to_csv(context, sales_data):
    """Transform the sales data into a CSV file."""
    csv_file_path = file_relative_path(__file__, "sales_data.csv")
    sales_data.to_csv(csv_file_path, index=False)
    return csv_file_path


@op(
    ins={"csv_file_path": In(dagster_type=str)},
    out={"pdf_file_path": Out(dagster_type=str)},
    retry_policy=RetryPolicy(max_retries=2),
)
def generate_pdf_chart(context, csv_file_path):
    """Generate a PDF chart visualization from the CSV file."""
    sales_data = pd.read_csv(csv_file_path)
    plt.figure(figsize=(10, 5))
    plt.plot(sales_data["date"], sales_data["amount"])
    plt.title("Daily Sales Report")
    plt.xlabel("Date")
    plt.ylabel("Sales Amount")
    pdf_file_path = file_relative_path(__file__, "sales_report.pdf")
    plt.savefig(pdf_file_path)
    return pdf_file_path


@op(
    ins={"pdf_file_path": In(dagster_type=str)},
    required_resource_keys={"email_system"},
    retry_policy=RetryPolicy(max_retries=2),
)
def email_sales_report(context, pdf_file_path):
    """Email the sales report PDF to management."""
    msg = MIMEMultipart()
    msg["From"] = context.resource_config["from_email"]
    msg["To"] = context.resource_config["to_email"]
    msg["Subject"] = "Daily Sales Report"
    body = "Please find the attached daily sales report."
    msg.attach(MIMEText(body, "plain"))

    with open(pdf_file_path, "rb") as attachment:
        part = MIMEApplication(attachment.read(), _subtype="pdf")
        part.add_header("Content-Disposition", "attachment", filename="sales_report.pdf")
        msg.attach(part)

    server = context.resources.email_system
    server.starttls()
    server.login(context.resource_config["from_email"], context.resource_config["email_password"])
    server.sendmail(msg["From"], msg["To"], msg.as_string())
    server.quit()


@job(
    name="query_sales_data_pipeline",
    description="Comprehensive pipeline that generates daily sales reports by querying PostgreSQL sales data, transforming it into CSV format, creating a PDF chart visualization, and emailing the final report to management.",
    executor_def=in_process_executor,
    resource_defs={
        "postgres_default": postgres_default,
        "email_system": email_system,
        "io_manager": fs_io_manager,
    },
)
def query_sales_data_pipeline():
    pdf_file_path = generate_pdf_chart(transform_to_csv(query_sales_data()))
    email_sales_report(pdf_file_path)


@schedule(
    job=query_sales_data_pipeline,
    cron_schedule="@daily",
    execution_timezone="UTC",
    name="daily_sales_report_schedule",
    catchup=False,
)
def daily_sales_report_schedule(_context):
    return {}
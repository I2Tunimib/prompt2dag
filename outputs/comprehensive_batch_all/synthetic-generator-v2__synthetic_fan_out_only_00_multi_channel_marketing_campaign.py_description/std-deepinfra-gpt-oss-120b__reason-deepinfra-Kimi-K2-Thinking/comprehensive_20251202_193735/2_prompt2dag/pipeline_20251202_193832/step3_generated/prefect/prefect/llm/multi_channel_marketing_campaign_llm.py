# Generated by Prefect Pipeline Generator
# Date: 2024-11-04
# Prefect version: 2.14.0
# Pipeline: multi_channel_marketing_campaign

import io
import logging
from typing import Any, Dict, List

import pandas as pd
import requests
from prefect import flow, task, get_run_logger
from prefect.deployments import DeploymentSpec
from prefect.server.schemas.schedules import CronSchedule
from prefect.task_runners import ConcurrentTaskRunner
from prefect.blocks.system import Secret
from prefect.filesystems import LocalFileSystem


@task(
    retries=2,
    retry_delay_seconds=60,
    description="Load the customer segment CSV from the configured local filesystem block.",
)
def load_customer_segment_csv() -> pd.DataFrame:
    """
    Reads ``customer_segments.csv`` from the ``local_customer_segment_filesystem`` block
    and returns a pandas DataFrame.

    Returns
    -------
    pd.DataFrame
        DataFrame containing the customer segment data.
    """
    logger = get_run_logger()
    try:
        # Load the LocalFileSystem block
        fs_block: LocalFileSystem = LocalFileSystem.load("local_customer_segment_filesystem")
        logger.info("Loaded LocalFileSystem block 'local_customer_segment_filesystem'.")

        # Read the CSV file as bytes
        csv_bytes: bytes = fs_block.read_path("customer_segments.csv")
        logger.info("Read 'customer_segments.csv' (%d bytes).", len(csv_bytes))

        # Convert bytes to a DataFrame
        df = pd.read_csv(io.BytesIO(csv_bytes))
        logger.info("Loaded CSV into DataFrame with %d rows and %d columns.", df.shape[0], df.shape[1])
        return df
    except Exception as exc:
        logger.error("Failed to load customer segment CSV: %s", exc)
        raise


def _post_to_api(endpoint: str, payload: Dict[str, Any], api_key: str) -> requests.Response:
    """
    Helper function to POST a JSON payload to a given endpoint using an API key.

    Parameters
    ----------
    endpoint : str
        The full URL of the API endpoint.
    payload : dict
        JSON-serializable payload.
    api_key : str
        Authentication token or API key.

    Returns
    -------
    requests.Response
        The response object from the request.
    """
    headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
    response = requests.post(endpoint, json=payload, headers=headers, timeout=30)
    response.raise_for_status()
    return response


@task(
    retries=2,
    retry_delay_seconds=60,
    description="Send an email campaign to each customer in the segment.",
)
def send_email_campaign(customer_df: pd.DataFrame) -> List[Dict[str, Any]]:
    """
    Sends an email campaign using the Email Delivery Service API.

    Parameters
    ----------
    customer_df : pd.DataFrame
        DataFrame containing customer information (must include an ``email`` column).

    Returns
    -------
    list of dict
        List of API responses for each email sent.
    """
    logger = get_run_logger()
    try:
        secret: Secret = Secret.load("email_delivery_api")
        api_key = secret.get()
        logger.info("Retrieved Email Delivery API secret.")

        endpoint = "https://api.emailservice.example.com/v1/send"
        responses = []

        for _, row in customer_df.iterrows():
            payload = {
                "to": row["email"],
                "subject": "Our Latest Offer!",
                "body": "Hello, check out our new products...",
            }
            logger.debug("Sending email to %s", row["email"])
            resp = _post_to_api(endpoint, payload, api_key)
            responses.append(resp.json())
            logger.info("Email sent to %s (status: %s)", row["email"], resp.status_code)

        return responses
    except Exception as exc:
        logger.error("Failed to send email campaign: %s", exc)
        raise


@task(
    retries=2,
    retry_delay_seconds=60,
    description="Send an SMS campaign to each customer in the segment.",
)
def send_sms_campaign(customer_df: pd.DataFrame) -> List[Dict[str, Any]]:
    """
    Sends an SMS campaign using the SMS Gateway Service API.

    Parameters
    ----------
    customer_df : pd.DataFrame
        DataFrame containing customer information (must include a ``phone_number`` column).

    Returns
    -------
    list of dict
        List of API responses for each SMS sent.
    """
    logger = get_run_logger()
    try:
        secret: Secret = Secret.load("sms_gateway_api")
        api_key = secret.get()
        logger.info("Retrieved SMS Gateway API secret.")

        endpoint = "https://api.smsgateway.example.com/v1/send"
        responses = []

        for _, row in customer_df.iterrows():
            payload = {
                "to": row["phone_number"],
                "message": "Check out our latest offers!",
            }
            logger.debug("Sending SMS to %s", row["phone_number"])
            resp = _post_to_api(endpoint, payload, api_key)
            responses.append(resp.json())
            logger.info("SMS sent to %s (status: %s)", row["phone_number"], resp.status_code)

        return responses
    except Exception as exc:
        logger.error("Failed to send SMS campaign: %s", exc)
        raise


@task(
    retries=2,
    retry_delay_seconds=60,
    description="Send a push notification campaign to each customer in the segment.",
)
def send_push_notification(customer_df: pd.DataFrame) -> List[Dict[str, Any]]:
    """
    Sends a push notification campaign using the Push Notification Service API.

    Parameters
    ----------
    customer_df : pd.DataFrame
        DataFrame containing customer information (must include a ``device_token`` column).

    Returns
    -------
    list of dict
        List of API responses for each push notification sent.
    """
    logger = get_run_logger()
    try:
        secret: Secret = Secret.load("push_notification_api")
        api_key = secret.get()
        logger.info("Retrieved Push Notification API secret.")

        endpoint = "https://api.pushservice.example.com/v1/notify"
        responses = []

        for _, row in customer_df.iterrows():
            payload = {
                "device_token": row["device_token"],
                "title": "New Promotion!",
                "body": "Tap to see our latest deals.",
            }
            logger.debug("Sending push notification to device %s", row["device_token"])
            resp = _post_to_api(endpoint, payload, api_key)
            responses.append(resp.json())
            logger.info(
                "Push notification sent to device %s (status: %s)",
                row["device_token"],
                resp.status_code,
            )

        return responses
    except Exception as exc:
        logger.error("Failed to send push notification campaign: %s", exc)
        raise


@flow(
    name="multi_channel_marketing_campaign",
    task_runner=ConcurrentTaskRunner(),
    description="Executes a multi-channel marketing campaign by loading customer segment data "
    "and triggering parallel email, SMS, and push notification campaigns.",
)
def multi_channel_marketing_campaign() -> None:
    """
    Orchestrates the loading of customer segment data and the parallel execution of
    email, SMS, and push notification campaigns.
    """
    logger = get_run_logger()
    logger.info("Starting multi-channel marketing campaign flow.")

    # Load the customer segment data
    customer_df = load_customer_segment_csv()

    # Fan‑out to the three campaign tasks; they run concurrently thanks to the
    # ConcurrentTaskRunner.
    send_email_campaign(customer_df)
    send_sms_campaign(customer_df)
    send_push_notification(customer_df)

    logger.info("All campaign tasks have been dispatched.")


# -------------------------------------------------------------------------
# Deployment configuration (generated from specification)
# -------------------------------------------------------------------------

DeploymentSpec(
    name="multi_channel_marketing_campaign_deployment",
    flow=multi_channel_marketing_campaign,
    schedule=CronSchedule(cron="0 0 * * *", timezone="UTC"),  # @daily UTC
    tags=["marketing", "fanout"],
    work_pool_name="default-agent-pool",
    parameters={},
    description="Daily deployment of the multi‑channel marketing campaign flow.",
    enforce_parameter_schema=False,
    catchup=False,
)
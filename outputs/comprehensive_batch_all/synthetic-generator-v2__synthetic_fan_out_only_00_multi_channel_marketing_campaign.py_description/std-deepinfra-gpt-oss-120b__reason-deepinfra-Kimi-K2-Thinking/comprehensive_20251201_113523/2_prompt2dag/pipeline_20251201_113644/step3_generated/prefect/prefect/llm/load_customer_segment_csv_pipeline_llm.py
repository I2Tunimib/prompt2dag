# Generated by Prefect Pipeline Generator
# Date: 2024-06-30
# Pipeline: load_customer_segment_csv_pipeline
# Description: Comprehensive Pipeline Description
# Prefect version: 2.14.0

from __future__ import annotations

import os
from typing import Any, List

import pandas as pd
from prefect import flow, task, get_run_logger
from prefect.task_runners import ConcurrentTaskRunner
from prefect.exceptions import PrefectException
from prefect.filesystems import LocalFileSystem
from prefect.blocks.system import Secret


# -------------------------------------------------------------------------
# Helper Functions
# -------------------------------------------------------------------------
def _get_secret(secret_name: str) -> str:
    """
    Retrieve a secret value from a Prefect Secret block.

    Args:
        secret_name: Name of the Secret block.

    Returns:
        The secret value as a string.

    Raises:
        PrefectException: If the secret block cannot be loaded.
    """
    try:
        secret_block = Secret.load(secret_name)
        return secret_block.get()
    except Exception as exc:
        raise PrefectException(f"Unable to load secret '{secret_name}': {exc}") from exc


# -------------------------------------------------------------------------
# Tasks
# -------------------------------------------------------------------------
@task(retries=2, retry_delay_seconds=10, description="Load Customer Segment CSV")
def load_customer_segment_csv(
    filesystem_block_name: str = "local_csv_filesystem",
    csv_path: str = "data/customer_segment.csv",
) -> pd.DataFrame:
    """
    Load a customer segment CSV file from a local filesystem block.

    Args:
        filesystem_block_name: Name of the Prefect LocalFileSystem block.
        csv_path: Relative path to the CSV file within the block's base path.

    Returns:
        pandas.DataFrame containing the CSV data.

    Raises:
        PrefectException: If the file cannot be read.
    """
    logger = get_run_logger()
    logger.info("Loading CSV from filesystem block '%s' at path '%s'.", filesystem_block_name, csv_path)

    try:
        fs_block: LocalFileSystem = LocalFileSystem.load(filesystem_block_name)
        full_path = os.path.join(fs_block.basepath, csv_path)
        df = pd.read_csv(full_path)
        logger.info("Loaded %d records from CSV.", len(df))
        return df
    except Exception as exc:
        raise PrefectException(f"Failed to load CSV from '{csv_path}': {exc}") from exc


@task(retries=2, retry_delay_seconds=10, description="Send Email Campaign")
def send_email_campaign(
    customers: pd.DataFrame,
    secret_name: str = "email_delivery_api",
) -> List[Any]:
    """
    Send an email campaign to the provided customers.

    Args:
        customers: DataFrame containing customer data.
        secret_name: Name of the Secret block holding the email API key.

    Returns:
        List of responses from the email service.

    Raises:
        PrefectException: If the email service call fails.
    """
    logger = get_run_logger()
    api_key = _get_secret(secret_name)
    logger.info("Sending email campaign using API key from secret '%s'.", secret_name)

    responses = []
    for _, row in customers.iterrows():
        email = row.get("email")
        if not email:
            logger.warning("Skipping row without email address.")
            continue

        # Placeholder for actual email sending logic
        try:
            # Simulate API call
            response = {"email": email, "status": "sent"}
            responses.append(response)
            logger.debug("Email sent to %s.", email)
        except Exception as exc:
            raise PrefectException(f"Failed to send email to {email}: {exc}") from exc

    logger.info("Email campaign completed for %d recipients.", len(responses))
    return responses


@task(retries=2, retry_delay_seconds=10, description="Send Push Notification")
def send_push_notification(
    customers: pd.DataFrame,
    secret_name: str = "push_notification_api",
) -> List[Any]:
    """
    Send a push notification campaign to the provided customers.

    Args:
        customers: DataFrame containing customer data.
        secret_name: Name of the Secret block holding the push notification API key.

    Returns:
        List of responses from the push notification service.

    Raises:
        PrefectException: If the push notification service call fails.
    """
    logger = get_run_logger()
    api_key = _get_secret(secret_name)
    logger.info("Sending push notifications using secret '%s'.", secret_name)

    responses = []
    for _, row in customers.iterrows():
        device_token = row.get("device_token")
        if not device_token:
            logger.warning("Skipping row without device token.")
            continue

        # Placeholder for actual push notification logic
        try:
            response = {"device_token": device_token, "status": "sent"}
            responses.append(response)
            logger.debug("Push notification sent to token %s.", device_token)
        except Exception as exc:
            raise PrefectException(f"Failed to send push notification to {device_token}: {exc}") from exc

    logger.info("Push notification campaign completed for %d devices.", len(responses))
    return responses


@task(retries=2, retry_delay_seconds=10, description="Send SMS Campaign")
def send_sms_campaign(
    customers: pd.DataFrame,
    secret_name: str = "sms_gateway_api",
) -> List[Any]:
    """
    Send an SMS campaign to the provided customers.

    Args:
        customers: DataFrame containing customer data.
        secret_name: Name of the Secret block holding the SMS gateway API key.

    Returns:
        List of responses from the SMS gateway.

    Raises:
        PrefectException: If the SMS gateway call fails.
    """
    logger = get_run_logger()
    api_key = _get_secret(secret_name)
    logger.info("Sending SMS campaign using secret '%s'.", secret_name)

    responses = []
    for _, row in customers.iterrows():
        phone_number = row.get("phone_number")
        if not phone_number:
            logger.warning("Skipping row without phone number.")
            continue

        # Placeholder for actual SMS sending logic
        try:
            response = {"phone_number": phone_number, "status": "sent"}
            responses.append(response)
            logger.debug("SMS sent to %s.", phone_number)
        except Exception as exc:
            raise PrefectException(f"Failed to send SMS to {phone_number}: {exc}") from exc

    logger.info("SMS campaign completed for %d recipients.", len(responses))
    return responses


# -------------------------------------------------------------------------
# Flow Definition
# -------------------------------------------------------------------------
@flow(
    name="load_customer_segment_csv_pipeline",
    description="Comprehensive Pipeline Description",
    task_runner=ConcurrentTaskRunner(),
)
def load_customer_segment_csv_pipeline() -> None:
    """
    Orchestrates loading a customer segment CSV and fan‑out campaigns
    (email, push notification, SMS) to the loaded customers.
    """
    logger = get_run_logger()
    logger.info("Starting pipeline: load_customer_segment_csv_pipeline")

    # Load the CSV
    customers_df = load_customer_segment_csv()

    # Fan‑out to campaign tasks (executed concurrently)
    email_future = send_email_campaign.submit(customers_df)
    push_future = send_push_notification.submit(customers_df)
    sms_future = send_sms_campaign.submit(customers_df)

    # Wait for all campaigns to finish (optional, ensures proper logging)
    email_responses = email_future.result()
    push_responses = push_future.result()
    sms_responses = sms_future.result()

    logger.info(
        "Pipeline completed. Email: %d, Push: %d, SMS: %d",
        len(email_responses),
        len(push_responses),
        len(sms_responses),
    )


# -------------------------------------------------------------------------
# Entry Point
# -------------------------------------------------------------------------
if __name__ == "__main__":
    # Running the flow directly (useful for local testing)
    load_customer_segment_csv_pipeline()
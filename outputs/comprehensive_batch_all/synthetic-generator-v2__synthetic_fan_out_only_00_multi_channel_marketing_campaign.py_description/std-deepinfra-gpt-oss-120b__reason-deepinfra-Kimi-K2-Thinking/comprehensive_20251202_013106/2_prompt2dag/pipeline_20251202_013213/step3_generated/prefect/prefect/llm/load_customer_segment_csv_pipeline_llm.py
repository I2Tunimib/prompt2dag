# Generated by Prefect Pipeline Generator
# Date: 2024-06-13
# Pipeline: load_customer_segment_csv_pipeline
# Description: No description provided.
# Prefect version: 2.14.0

from pathlib import Path
from typing import Any

import pandas as pd
from prefect import flow, task, get_run_logger
from prefect.task_runners import ConcurrentTaskRunner
from prefect.filesystems import LocalFileSystem
from prefect.blocks.system import Secret


@task(retries=2, retry_delay_seconds=60)
def load_customer_segment_csv(csv_path: str) -> pd.DataFrame:
    """
    Load a customer segment CSV file from the local file system.

    Args:
        csv_path: Relative or absolute path to the CSV file.

    Returns:
        pandas.DataFrame containing the CSV data.

    Raises:
        FileNotFoundError: If the CSV file does not exist.
        pd.errors.ParserError: If the CSV cannot be parsed.
    """
    logger = get_run_logger()
    logger.info("Loading customer segment CSV from %s", csv_path)

    # Retrieve the LocalFileSystem block (named "local_csv_fs")
    try:
        local_fs: LocalFileSystem = LocalFileSystem.load("local_csv_fs")
    except Exception as exc:
        logger.error("Failed to load LocalFileSystem block 'local_csv_fs': %s", exc)
        raise

    # Resolve the full path using the block's basepath (if any)
    base_path = Path(local_fs.basepath or "")
    full_path = base_path / csv_path

    if not full_path.is_file():
        raise FileNotFoundError(f"CSV file not found at {full_path}")

    df = pd.read_csv(full_path)
    logger.info("Loaded %d rows from %s", len(df), full_path)
    return df


@task(retries=2, retry_delay_seconds=60)
def send_email_campaign(customers: pd.DataFrame) -> None:
    """
    Send an email campaign to the customers in the provided DataFrame.

    This task retrieves the email service API key from a Prefect Secret block
    named ``email_service_api`` and simulates sending emails.

    Args:
        customers: DataFrame containing at least an ``email`` column.

    Raises:
        KeyError: If the ``email`` column is missing.
        Exception: If the email service call fails.
    """
    logger = get_run_logger()
    logger.info("Preparing to send email campaign to %d customers", len(customers))

    try:
        email_secret: Secret = Secret.load("email_service_api")
        email_api_key = email_secret.get()
    except Exception as exc:
        logger.error("Failed to retrieve email service API secret: %s", exc)
        raise

    if "email" not in customers.columns:
        raise KeyError("Column 'email' not found in customer data")

    # Placeholder for actual email sending logic
    for email in customers["email"].dropna().unique():
        logger.debug("Sending email to %s using API key %s", email, email_api_key[:4] + "****")
        # Insert real email sending code here

    logger.info("Email campaign completed")


@task(retries=2, retry_delay_seconds=60)
def send_sms_campaign(customers: pd.DataFrame) -> None:
    """
    Send an SMS campaign to the customers in the provided DataFrame.

    Retrieves the SMS gateway API key from a Prefect Secret block named
    ``sms_gateway_api`` and simulates sending SMS messages.

    Args:
        customers: DataFrame containing at least a ``phone_number`` column.

    Raises:
        KeyError: If the ``phone_number`` column is missing.
        Exception: If the SMS service call fails.
    """
    logger = get_run_logger()
    logger.info("Preparing to send SMS campaign to %d customers", len(customers))

    try:
        sms_secret: Secret = Secret.load("sms_gateway_api")
        sms_api_key = sms_secret.get()
    except Exception as exc:
        logger.error("Failed to retrieve SMS gateway API secret: %s", exc)
        raise

    if "phone_number" not in customers.columns:
        raise KeyError("Column 'phone_number' not found in customer data")

    # Placeholder for actual SMS sending logic
    for phone in customers["phone_number"].dropna().unique():
        logger.debug("Sending SMS to %s using API key %s", phone, sms_api_key[:4] + "****")
        # Insert real SMS sending code here

    logger.info("SMS campaign completed")


@task(retries=2, retry_delay_seconds=60)
def send_push_notification(customers: pd.DataFrame) -> None:
    """
    Send a push notification campaign to the customers in the provided DataFrame.

    Retrieves the push notification service API key from a Prefect Secret block
    named ``push_notification_service_api`` and simulates sending push notifications.

    Args:
        customers: DataFrame containing at least a ``device_token`` column.

    Raises:
        KeyError: If the ``device_token`` column is missing.
        Exception: If the push notification service call fails.
    """
    logger = get_run_logger()
    logger.info("Preparing to send push notifications to %d customers", len(customers))

    try:
        push_secret: Secret = Secret.load("push_notification_service_api")
        push_api_key = push_secret.get()
    except Exception as exc:
        logger.error("Failed to retrieve push notification service API secret: %s", exc)
        raise

    if "device_token" not in customers.columns:
        raise KeyError("Column 'device_token' not found in customer data")

    # Placeholder for actual push notification logic
    for token in customers["device_token"].dropna().unique():
        logger.debug(
            "Sending push notification to token %s using API key %s",
            token,
            push_api_key[:4] + "****",
        )
        # Insert real push notification code here

    logger.info("Push notification campaign completed")


@flow(
    name="load_customer_segment_csv_pipeline",
    task_runner=ConcurrentTaskRunner(),
)
def load_customer_segment_csv_pipeline(csv_path: str = "data/customer_segment.csv") -> Any:
    """
    Orchestrates loading a customer segment CSV and fan‑out campaigns via
    email, SMS, and push notifications.

    The flow follows a fan‑out pattern:
        1. Load the CSV.
        2. In parallel, send email, SMS, and push notifications.

    Args:
        csv_path: Path to the CSV file relative to the ``local_csv_fs`` block.

    Returns:
        A dictionary with the status of each campaign task.
    """
    logger = get_run_logger()
    logger.info("Starting load_customer_segment_csv_pipeline flow")

    # Step 1: Load CSV
    customers_df = load_customer_segment_csv(csv_path)

    # Step 2: Fan‑out to campaign tasks (executed concurrently)
    email_future = send_email_campaign.submit(customers_df)
    sms_future = send_sms_campaign.submit(customers_df)
    push_future = send_push_notification.submit(customers_df)

    # Wait for all to complete and collect results
    email_future.result()
    sms_future.result()
    push_future.result()

    logger.info("All campaign tasks completed")
    return {
        "email_campaign": "completed",
        "sms_campaign": "completed",
        "push_notification_campaign": "completed",
    }


if __name__ == "__main__":
    # Example local execution; in production this flow would be triggered via a
    # Prefect deployment (see orchestrator‑specific configuration).
    load_customer_segment_csv_pipeline()
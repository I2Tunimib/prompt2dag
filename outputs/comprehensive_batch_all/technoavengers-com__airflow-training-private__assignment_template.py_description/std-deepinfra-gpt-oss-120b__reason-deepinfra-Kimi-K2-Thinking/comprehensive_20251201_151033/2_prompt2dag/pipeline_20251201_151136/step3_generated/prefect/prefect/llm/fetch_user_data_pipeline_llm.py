# Generated by Prefect Pipeline Generator
# Date: 2024-06-28
# Pipeline: fetch_user_data_pipeline
# Description: No description provided.
# Prefect version: 2.14.0

import requests
import sqlalchemy
from prefect import flow, task
from prefect.task_runners import SequentialTaskRunner
from prefect.deployments import DeploymentSpec
from prefect.server.schemas.schedules import CronSchedule
from prefect.blocks.system import Secret


@task(retries=0)
def fetch_user_data() -> list[dict]:
    """
    Fetch user data from the ReqRes API.

    Returns:
        A list of dictionaries containing raw user data.
    """
    # Load the secret containing the base URL for the ReqRes API
    secret = Secret.load("reqres_http_api")
    base_url = secret.get()  # Expected to be something like "https://reqres.in"

    try:
        response = requests.get(f"{base_url}/api/users")
        response.raise_for_status()
        data = response.json()
        return data.get("data", [])
    except requests.RequestException as exc:
        raise RuntimeError(f"Failed to fetch user data: {exc}") from exc


@task(retries=0)
def transform_user_data(raw_data: list[dict]) -> list[dict]:
    """
    Transform raw user data into the schema required for the database.

    Args:
        raw_data: List of raw user dictionaries from the API.

    Returns:
        A list of transformed user dictionaries.
    """
    transformed = []
    for user in raw_data:
        transformed.append(
            {
                "id": user["id"],
                "first_name": user["first_name"],
                "last_name": user["last_name"],
                "email": user["email"],
                "avatar": user["avatar"],
            }
        )
    return transformed


@task(retries=0)
def create_user_table() -> bool:
    """
    Create the `users` table in PostgreSQL if it does not already exist.

    Returns:
        True if the table creation statement executed successfully.
    """
    # Load the secret containing the PostgreSQL connection string
    secret = Secret.load("postgres_db")
    connection_string = secret.get()  # Expected format: postgresql://user:pass@host/db

    engine = sqlalchemy.create_engine(connection_string)

    create_sql = """
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY,
        first_name VARCHAR(50),
        last_name VARCHAR(50),
        email VARCHAR(100),
        avatar TEXT
    );
    """

    try:
        with engine.begin() as conn:
            conn.execute(sqlalchemy.text(create_sql))
        return True
    except sqlalchemy.exc.SQLAlchemyError as exc:
        raise RuntimeError(f"Failed to create users table: {exc}") from exc


@task(retries=0)
def insert_user_data(user_data: list[dict]) -> bool:
    """
    Insert transformed user data into the PostgreSQL `users` table.

    Args:
        user_data: List of transformed user dictionaries.

    Returns:
        True if the insert operation completed successfully.
    """
    secret = Secret.load("postgres_db")
    connection_string = secret.get()

    engine = sqlalchemy.create_engine(connection_string)

    insert_sql = """
    INSERT INTO users (id, first_name, last_name, email, avatar)
    VALUES (:id, :first_name, :last_name, :email, :avatar)
    ON CONFLICT (id) DO UPDATE SET
        first_name = EXCLUDED.first_name,
        last_name = EXCLUDED.last_name,
        email = EXCLUDED.email,
        avatar = EXCLUDED.avatar;
    """

    try:
        with engine.begin() as conn:
            conn.execute(sqlalchemy.text(insert_sql), user_data)
        return True
    except sqlalchemy.exc.SQLAlchemyError as exc:
        raise RuntimeError(f"Failed to insert user data: {exc}") from exc


@flow(
    name="fetch_user_data_pipeline",
    task_runner=SequentialTaskRunner(),
)
def fetch_user_data_pipeline() -> None:
    """
    Orchestrates the fetching, transformation, table creation,
    and insertion of user data into PostgreSQL.
    """
    raw = fetch_user_data()
    transformed = transform_user_data(raw)
    create_user_table()
    insert_user_data(transformed)


# Deployment configuration
DeploymentSpec(
    name="fetch_user_data_pipeline_deployment",
    flow=fetch_user_data_pipeline,
    schedule=CronSchedule(cron="0 0 * * *", timezone="UTC"),
    work_pool_name="default-agent-pool",
    tags=[],
    description="Daily deployment of fetch_user_data_pipeline",
)
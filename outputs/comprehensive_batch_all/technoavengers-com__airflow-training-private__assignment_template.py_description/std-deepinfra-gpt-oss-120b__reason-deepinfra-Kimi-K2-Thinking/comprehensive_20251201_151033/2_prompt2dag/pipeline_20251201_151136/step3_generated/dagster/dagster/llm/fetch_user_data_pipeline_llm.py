# Generated by Dagster Code Generator
# Date: 2024-06-13
# Pipeline: fetch_user_data_pipeline
# Description: No description provided.

from typing import Any, Dict, List

import requests
import psycopg2
from dagster import (
    op,
    job,
    In,
    Out,
    ResourceDefinition,
    fs_io_manager,
    ScheduleDefinition,
    in_process_executor,
    InitResourceContext,
    ConfigurableResource,
)


# ----------------------------------------------------------------------
# Resources
# ----------------------------------------------------------------------
class ReqResAPIResource(ConfigurableResource):
    """Resource for interacting with the ReqRes public API."""

    base_url: str = "https://reqres.in/api"

    def get_users(self) -> List[Dict[str, Any]]:
        """Fetch a list of users from the ReqRes API."""
        response = requests.get(f"{self.base_url}/users")
        response.raise_for_status()
        data = response.json()
        return data.get("data", [])


class PostgresResource(ConfigurableResource):
    """Resource for connecting to a PostgreSQL database."""

    host: str
    port: int = 5432
    dbname: str
    user: str
    password: str

    def get_connection(self):
        """Create a new psycopg2 connection."""
        return psycopg2.connect(
            host=self.host,
            port=self.port,
            dbname=self.dbname,
            user=self.user,
            password=self.password,
        )

    def execute(self, query: str, params: tuple = ()):
        """Execute a query without returning results."""
        with self.get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute(query, params)
                conn.commit()


# ----------------------------------------------------------------------
# Ops
# ----------------------------------------------------------------------
@op(
    required_resource_keys={"reqres"},
    out=Out(dagster_type=List[Dict[str, Any]], description="Raw user data from ReqRes API"),
    description="Fetch user data from the ReqRes API.",
)
def fetch_user_data(context) -> List[Dict[str, Any]]:
    """Calls the ReqRes API and returns a list of user dictionaries."""
    reqres: ReqResAPIResource = context.resources.reqres
    users = reqres.get_users()
    context.log.info(f"Fetched {len(users)} users from ReqRes.")
    return users


@op(
    ins={"raw_users": In(dagster_type=List[Dict[str, Any]])},
    out=Out(dagster_type=List[Dict[str, Any]], description="Transformed user data"),
    description="Transform raw user data into the shape required for the database.",
)
def transform_user_data(context, raw_users: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Selects and renames fields to match the target database schema."""
    transformed = [
        {
            "id": user["id"],
            "first_name": user["first_name"],
            "last_name": user["last_name"],
            "email": user["email"],
            "avatar": user["avatar"],
        }
        for user in raw_users
    ]
    context.log.info(f"Transformed {len(transformed)} user records.")
    return transformed


@op(
    required_resource_keys={"postgres"},
    description="Create the user table in PostgreSQL if it does not exist.",
)
def create_user_table(context):
    """Executes a DDL statement to ensure the target table exists."""
    postgres: PostgresResource = context.resources.postgres
    create_table_sql = """
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY,
        first_name VARCHAR(50),
        last_name VARCHAR(50),
        email VARCHAR(255),
        avatar TEXT
    );
    """
    postgres.execute(create_table_sql)
    context.log.info("User table ensured in PostgreSQL.")


@op(
    required_resource_keys={"postgres"},
    ins={"users": In(dagster_type=List[Dict[str, Any]])},
    description="Insert transformed user data into the PostgreSQL users table.",
)
def insert_user_data(context, users: List[Dict[str, Any]]):
    """Bulk inserts user records into the PostgreSQL table."""
    if not users:
        context.log.warning("No user data provided to insert.")
        return

    postgres: PostgresResource = context.resources.postgres
    insert_sql = """
    INSERT INTO users (id, first_name, last_name, email, avatar)
    VALUES (%s, %s, %s, %s, %s)
    ON CONFLICT (id) DO UPDATE SET
        first_name = EXCLUDED.first_name,
        last_name = EXCLUDED.last_name,
        email = EXCLUDED.email,
        avatar = EXCLUDED.avatar;
    """
    params = [
        (u["id"], u["first_name"], u["last_name"], u["email"], u["avatar"])
        for u in users
    ]

    with postgres.get_connection() as conn:
        with conn.cursor() as cur:
            cur.executemany(insert_sql, params)
        conn.commit()
    context.log.info(f"Inserted/updated {len(users)} user records into PostgreSQL.")


# ----------------------------------------------------------------------
# Job
# ----------------------------------------------------------------------
@job(
    executor_def=in_process_executor,
    resource_defs={
        "reqres": ReqResAPIResource(),
        "postgres": PostgresResource(
            host="localhost",
            dbname="mydb",
            user="myuser",
            password="mypassword",
        ),
        "io_manager": fs_io_manager,
    },
    description="No description provided.",
)
def fetch_user_data_pipeline():
    """Orchestrates fetching, transforming, and loading user data into PostgreSQL."""
    raw = fetch_user_data()
    transformed = transform_user_data(raw)
    create_user_table()
    insert_user_data(transformed)


# ----------------------------------------------------------------------
# Schedule
# ----------------------------------------------------------------------
daily_fetch_schedule = ScheduleDefinition(
    job=fetch_user_data_pipeline,
    cron_schedule="@daily",
    execution_timezone="UTC",
    description="Daily execution of the fetch_user_data_pipeline.",
    default_status="RUNNING",  # Enabled
    tags={"catchup": "false"},
)


# ----------------------------------------------------------------------
# Entry point for Dagster UI / CLI
# ----------------------------------------------------------------------
if __name__ == "__main__":
    # This block allows the module to be run directly for quick testing.
    from dagster import execute_job

    result = execute_job(fetch_user_data_pipeline)
    assert result.success
# Generated by Dagster code generator
# Date: 2024-06-12
# Description: Dagster job for fetching, transforming, and loading user data into PostgreSQL.

from typing import List, Dict, Any

import requests
import psycopg2
from psycopg2.extras import execute_values

from dagster import (
    op,
    job,
    In,
    Out,
    Nothing,
    RetryPolicy,
    ResourceDefinition,
    ConfigurableResource,
    InitResourceContext,
    Output,
    fs_io_manager,
    InProcessExecutor,
    ScheduleDefinition,
    ScheduleStatus,
    Definitions,
)


# ----------------------------------------------------------------------
# Resources
# ----------------------------------------------------------------------


class ReqResResource(ConfigurableResource):
    """Resource for interacting with the ReqRes public API."""

    base_url: str = "https://reqres.in"

    def get_users(self) -> List[Dict[str, Any]]:
        """Fetches a list of users from the ReqRes API."""
        response = requests.get(f"{self.base_url}/api/users")
        response.raise_for_status()
        data = response.json()
        return data.get("data", [])


class PostgresResource(ConfigurableResource):
    """Resource for connecting to a PostgreSQL database."""

    host: str
    port: int = 5432
    dbname: str
    user: str
    password: str

    def get_connection(self):
        """Creates a new psycopg2 connection."""
        return psycopg2.connect(
            host=self.host,
            port=self.port,
            dbname=self.dbname,
            user=self.user,
            password=self.password,
        )


# ----------------------------------------------------------------------
# Ops
# ----------------------------------------------------------------------


@op(
    name="fetch_user_data",
    description="Fetch user data from the ReqRes API.",
    out=Out(List[Dict[str, Any]]),
    required_resource_keys={"reqres"},
    retry_policy=RetryPolicy(max_retries=0),
)
def fetch_user_data(context) -> List[Dict[str, Any]]:
    """Calls the ReqRes API and returns raw user records."""
    reqres: ReqResResource = context.resources.reqres
    users = reqres.get_users()
    context.log.info(f"Fetched {len(users)} users from ReqRes.")
    return users


@op(
    name="transform_user_data",
    description="Transform raw user data into a flat structure suitable for DB insertion.",
    ins={"raw_users": In(List[Dict[str, Any]])},
    out=Out(List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=0),
)
def transform_user_data(context, raw_users: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Flattens nested user objects and selects relevant fields."""
    transformed = []
    for user in raw_users:
        transformed.append(
            {
                "id": user["id"],
                "email": user["email"],
                "first_name": user["first_name"],
                "last_name": user["last_name"],
                "avatar": user["avatar"],
            }
        )
    context.log.info(f"Transformed {len(transformed)} user records.")
    return transformed


@op(
    name="create_user_table",
    description="Create the users table in PostgreSQL if it does not exist.",
    ins={"_": In(Nothing)},
    out=Out(Nothing),
    required_resource_keys={"postgres"},
    retry_policy=RetryPolicy(max_retries=0),
)
def create_user_table(context) -> Nothing:
    """Executes DDL to ensure the target table exists."""
    postgres: PostgresResource = context.resources.postgres
    create_table_sql = """
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY,
        email TEXT NOT NULL,
        first_name TEXT,
        last_name TEXT,
        avatar TEXT
    );
    """
    with postgres.get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(create_table_sql)
        conn.commit()
    context.log.info("Ensured users table exists.")
    return Nothing


@op(
    name="insert_user_data",
    description="Insert transformed user data into the PostgreSQL users table.",
    ins={"users": In(List[Dict[str, Any]])},
    out=Out(Nothing),
    required_resource_keys={"postgres"},
    retry_policy=RetryPolicy(max_retries=0),
)
def insert_user_data(context, users: List[Dict[str, Any]]) -> Nothing:
    """Bulk inserts user rows into the database."""
    if not users:
        context.log.info("No user data to insert.")
        return Nothing

    postgres: PostgresResource = context.resources.postgres
    insert_sql = """
    INSERT INTO users (id, email, first_name, last_name, avatar)
    VALUES %s
    ON CONFLICT (id) DO UPDATE SET
        email = EXCLUDED.email,
        first_name = EXCLUDED.first_name,
        last_name = EXCLUDED.last_name,
        avatar = EXCLUDED.avatar;
    """
    values = [(u["id"], u["email"], u["first_name"], u["last_name"], u["avatar"]) for u in users]

    with postgres.get_connection() as conn:
        with conn.cursor() as cur:
            execute_values(cur, insert_sql, values)
        conn.commit()
    context.log.info(f"Inserted/updated {len(users)} user records.")
    return Nothing


# ----------------------------------------------------------------------
# Job definition
# ----------------------------------------------------------------------


@job(
    name="fetch_user_data_pipeline",
    description="No description provided.",
    executor_def=InProcessExecutor(),
    resource_defs={
        "reqres": ReqResResource(),
        "postgres": PostgresResource(),
        "io_manager": fs_io_manager,
    },
    config=None,
)
def fetch_user_data_pipeline():
    """Orchestrates fetching, transforming, and loading user data."""
    raw = fetch_user_data()
    transformed = transform_user_data(raw)
    create_user_table()
    insert_user_data(transformed)


# ----------------------------------------------------------------------
# Schedule
# ----------------------------------------------------------------------


daily_schedule = ScheduleDefinition(
    job=fetch_user_data_pipeline,
    cron_schedule="@daily",
    execution_timezone="UTC",
    default_status=ScheduleStatus.RUNNING,
    name="fetch_user_data_daily_schedule",
)


# ----------------------------------------------------------------------
# Definitions (for Dagster UI)
# ----------------------------------------------------------------------


defs = Definitions(
    jobs=[fetch_user_data_pipeline],
    schedules=[daily_schedule],
    resources={
        "reqres": ReqResResource(),
        "postgres": PostgresResource(),
        "io_manager": fs_io_manager,
    },
)
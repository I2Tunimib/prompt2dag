# Generated by Prefect Pipeline Generator on 2024-06-28
# Pipeline: fetch_user_data_pipeline
# Description: No description provided.
# Prefect version: 2.14.0

import json
import os
from typing import List, Dict

import requests
from sqlalchemy import create_engine, text
from sqlalchemy.exc import SQLAlchemyError

from prefect import flow, task, get_run_logger
from prefect.task_runners import SequentialTaskRunner
from prefect.deployments import DeploymentSpec
from prefect.server.schemas.schedules import CronSchedule
from prefect.blocks.system import Secret


@task(retries=0, name="Fetch User Data from API")
def fetch_user_data() -> List[Dict]:
    """
    Retrieve user data from the ReqRes API.

    Returns:
        List[Dict]: A list of user dictionaries.
    """
    logger = get_run_logger()
    try:
        # Load the API base URL or token from a Prefect Secret block
        api_secret = Secret.load("reqres_api")
        api_config = json.loads(api_secret.get())
        base_url = api_config.get("base_url", "https://reqres.in/api")
        endpoint = api_config.get("endpoint", "/users")
        url = f"{base_url.rstrip('/')}{endpoint}"
        logger.info(f"Requesting user data from {url}")

        response = requests.get(url, timeout=30)
        response.raise_for_status()
        data = response.json()
        users = data.get("data", [])
        logger.info(f"Fetched {len(users)} users.")
        return users
    except (requests.RequestException, json.JSONDecodeError) as exc:
        logger.error(f"Failed to fetch user data: {exc}")
        raise


@task(retries=0, name="Transform User Data")
def transform_user_data(raw_users: List[Dict]) -> List[Dict]:
    """
    Transform raw user data into a flat structure suitable for database insertion.

    Args:
        raw_users (List[Dict]): Raw user dictionaries from the API.

    Returns:
        List[Dict]: Transformed user dictionaries.
    """
    logger = get_run_logger()
    transformed = []
    for user in raw_users:
        transformed_user = {
            "id": user.get("id"),
            "email": user.get("email"),
            "first_name": user.get("first_name"),
            "last_name": user.get("last_name"),
            "avatar": user.get("avatar"),
        }
        transformed.append(transformed_user)
    logger.info(f"Transformed {len(transformed)} users.")
    return transformed


@task(retries=0, name="Create Users Table in PostgreSQL")
def create_user_table():
    """
    Ensure the target PostgreSQL table exists.
    """
    logger = get_run_logger()
    try:
        # Load DB connection string from a Prefect Secret block
        db_secret = Secret.load("postgres_db")
        db_config = json.loads(db_secret.get())
        connection_string = db_config.get("connection_string")
        if not connection_string:
            raise ValueError("PostgreSQL connection string not found in secret.")

        engine = create_engine(connection_string)
        create_table_sql = """
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY,
            email TEXT NOT NULL,
            first_name TEXT,
            last_name TEXT,
            avatar TEXT
        );
        """
        with engine.begin() as conn:
            conn.execute(text(create_table_sql))
        logger.info("Users table ensured in PostgreSQL.")
    except (SQLAlchemyError, ValueError) as exc:
        logger.error(f"Failed to create users table: {exc}")
        raise


@task(retries=0, name="Insert User Data into PostgreSQL")
def insert_user_data(users: List[Dict]):
    """
    Insert transformed user data into the PostgreSQL users table.

    Args:
        users (List[Dict]): List of transformed user dictionaries.
    """
    logger = get_run_logger()
    if not users:
        logger.warning("No user data to insert.")
        return

    try:
        db_secret = Secret.load("postgres_db")
        db_config = json.loads(db_secret.get())
        connection_string = db_config.get("connection_string")
        if not connection_string:
            raise ValueError("PostgreSQL connection string not found in secret.")

        engine = create_engine(connection_string)
        insert_sql = """
        INSERT INTO users (id, email, first_name, last_name, avatar)
        VALUES (:id, :email, :first_name, :last_name, :avatar)
        ON CONFLICT (id) DO UPDATE SET
            email = EXCLUDED.email,
            first_name = EXCLUDED.first_name,
            last_name = EXCLUDED.last_name,
            avatar = EXCLUDED.avatar;
        """
        with engine.begin() as conn:
            conn.execute(text(insert_sql), users)
        logger.info(f"Inserted/updated {len(users)} users into PostgreSQL.")
    except (SQLAlchemyError, ValueError) as exc:
        logger.error(f"Failed to insert user data: {exc}")
        raise


@flow(
    name="fetch_user_data_pipeline",
    task_runner=SequentialTaskRunner(),
)
def fetch_user_data_pipeline():
    """
    Orchestrates fetching, transforming, and loading user data from ReqRes API
    into a PostgreSQL database.
    """
    raw_users = fetch_user_data()
    transformed_users = transform_user_data(raw_users)
    create_user_table()
    insert_user_data(transformed_users)


# Deployment configuration
DeploymentSpec(
    name="fetch_user_data_pipeline_deployment",
    flow=fetch_user_data_pipeline,
    schedule=CronSchedule(cron="0 0 * * *", timezone="UTC"),  # @daily UTC
    tags=["fetch_user_data"],
    work_pool_name="default-agent-pool",
    enforce_parameter_schema=False,
    flow_runner=SequentialTaskRunner(),
    description="Daily pipeline that fetches user data from ReqRes API and stores it in PostgreSQL.",
    catchup=False,
)

if __name__ == "__main__":
    # Running the flow locally for quick testing
    fetch_user_data_pipeline()
# Generated by Dagster Pipeline Generator
# Date: 2024-06-28
# Pipeline: PM2.5_Risk_Alert_Pipeline
# Description: Comprehensive Pipeline Description

from __future__ import annotations

from typing import Any, Dict

import dagster
from dagster import (
    In,
    Out,
    op,
    job,
    RetryPolicy,
    ConfigurableResource,
    ResourceDefinition,
    InitResourceContext,
    Output,
    Nothing,
    String,
    Bool,
    Dict as DagsterDict,
    Field,
    io_manager,
    fs_io_manager,
    InProcessExecutor,
)

# ----------------------------------------------------------------------
# Resource Definitions
# ----------------------------------------------------------------------


class MahidolAqiWebsiteResource(ConfigurableResource):
    """Resource for fetching AQI data from Mahidol University website."""

    base_url: str = Field(
        default="https://aqi.mahidol.ac.th",
        description="Base URL for Mahidol AQI website",
    )

    def fetch_html(self) -> str:
        """Placeholder method to fetch raw HTML."""
        # In production, implement actual HTTP request logic.
        return "<html>Mock Mahidol AQI HTML content</html>"


class PostgresWarehouseResource(ConfigurableResource):
    """Resource for interacting with PostgreSQL data warehouse."""

    connection_string: str = Field(
        default="postgresql://user:password@localhost:5432/warehouse",
        description="SQLAlchemy connection string for PostgreSQL",
    )

    def load_json(self, table: str, data: Dict[str, Any]) -> None:
        """Placeholder method to load JSON data into a table."""
        # In production, use SQLAlchemy or psycopg2 to insert data.
        print(f"Loading data into {table}: {data}")


class SmtpGmailResource(ConfigurableResource):
    """Resource for sending email via Gmail SMTP."""

    username: str = Field(default="example@gmail.com", description="Gmail username")
    password: str = Field(default="password", description="Gmail password")
    smtp_server: str = Field(default="smtp.gmail.com", description="SMTP server")
    smtp_port: int = Field(default=587, description="SMTP port")

    def send_email(self, subject: str, body: str, to: list[str]) -> None:
        """Placeholder method to send an email."""
        # In production, use smtplib or a third‑party email library.
        print(f"Sending email to {to}: {subject}\n{body}")


# ----------------------------------------------------------------------
# Ops
# ----------------------------------------------------------------------


@op(
    name="extract_mahidol_aqi_html",
    description="Fetch raw HTML from Mahidol AQI website.",
    out=Out(str),
    required_resource_keys={"mahidl_aqi_website"},
    retry_policy=RetryPolicy(max_retries=0),
)
def extract_mahidol_aqi_html(context: dagster.OpExecutionContext) -> str:
    """Extract raw HTML from the Mahidol AQI website."""
    html = context.resources.mahidl_aqi_website.fetch_html()
    context.log.info("Fetched HTML content.")
    return html


@op(
    name="transform_mahidol_aqi_json",
    description="Transform raw HTML into structured JSON.",
    ins={"html": In(str)},
    out=Out(DagsterDict),
    retry_policy=RetryPolicy(max_retries=0),
)
def transform_mahidol_aqi_json(context: dagster.OpExecutionContext, html: str) -> Dict[str, Any]:
    """Parse the HTML and produce a JSON representation."""
    # Placeholder parsing logic.
    json_data = {"pm25": 42, "status": "moderate", "source_html": html[:30]}
    context.log.info(f"Transformed HTML to JSON: {json_data}")
    return json_data


@op(
    name="duplicate_check_branch",
    description="Check if the incoming record already exists in the warehouse.",
    ins={"record": In(DagsterDict)},
    out=Out(bool),
    required_resource_keys={"postgres_warehouse"},
    retry_policy=RetryPolicy(max_retries=0),
)
def duplicate_check_branch(context: dagster.OpExecutionContext, record: Dict[str, Any]) -> bool:
    """Determine whether the record is a duplicate."""
    # Placeholder duplicate logic – always returns False (i.e., not a duplicate).
    context.log.info("Performing duplicate check (placeholder).")
    return False


@op(
    name="load_mahidol_aqi_postgres",
    description="Load transformed AQI JSON into PostgreSQL warehouse.",
    ins={
        "record": In(DagsterDict),
        "is_duplicate": In(bool),
    },
    out=Out(Nothing),
    required_resource_keys={"postgres_warehouse"},
    retry_policy=RetryPolicy(max_retries=0),
)
def load_mahidol_aqi_postgres(
    context: dagster.OpExecutionContext,
    record: Dict[str, Any],
    is_duplicate: bool,
) -> Nothing:
    """Load the AQI record into PostgreSQL if it is not a duplicate."""
    if is_duplicate:
        context.log.info("Record is a duplicate – skipping load.")
        return Output(value=None, output_name="result")
    context.resources.postgres_warehouse.load_json(table="mahidl_aqi", data=record)
    context.log.info("Record loaded into PostgreSQL.")
    return Output(value=None, output_name="result")


@op(
    name="alert_decision_branch",
    description="Decide whether a PM2.5 alert should be sent.",
    ins={"record": In(DagsterDict)},
    out=Out(bool),
    retry_policy=RetryPolicy(max_retries=0),
)
def alert_decision_branch(context: dagster.OpExecutionContext, record: Dict[str, Any]) -> bool:
    """Simple rule: send alert if PM2.5 > 35 µg/m³."""
    pm25 = record.get("pm25", 0)
    should_alert = pm25 > 35
    context.log.info(f"PM2.5 value {pm25} – alert needed: {should_alert}")
    return should_alert


@op(
    name="notify_pm25_email",
    description="Send an email alert when PM2.5 exceeds threshold.",
    ins={"record": In(DagsterDict), "send_alert": In(bool)},
    out=Out(Nothing),
    required_resource_keys={"smtp_gmail"},
    retry_policy=RetryPolicy(max_retries=0),
)
def notify_pm25_email(
    context: dagster.OpExecutionContext,
    record: Dict[str, Any],
    send_alert: bool,
) -> Nothing:
    """Send an email notification if the alert condition is met."""
    if not send_alert:
        context.log.info("Alert condition not met – no email sent.")
        return Output(value=None, output_name="result")
    subject = f"PM2.5 Alert: {record.get('pm25')} µg/m³"
    body = f"The latest PM2.5 measurement is {record.get('pm25')} µg/m³.\nStatus: {record.get('status')}."
    recipients = ["recipient@example.com"]
    context.resources.smtp_gmail.send_email(subject=subject, body=body, to=recipients)
    context.log.info("Alert email sent.")
    return Output(value=None, output_name="result")


# ----------------------------------------------------------------------
# Job Definition
# ----------------------------------------------------------------------


@job(
    name="PM2.5_Risk_Alert_Pipeline",
    description="Comprehensive Pipeline Description",
    executor_def=InProcessExecutor(),
    resource_defs={
        "mahidl_aqi_website": MahidolAqiWebsiteResource(),
        "postgres_warehouse": PostgresWarehouseResource(),
        "smtp_gmail": SmtpGmailResource(),
        "io_manager": fs_io_manager,
    },
)
def pm2_5_risk_alert_pipeline():
    """Sequential pipeline that extracts, transforms, checks, loads, and alerts on Mahidol AQI data."""
    # Extraction & transformation
    raw_html = extract_mahidol_aqi_html()
    json_record = transform_mahidol_aqi_json(raw_html)

    # Branches
    is_duplicate = duplicate_check_branch(json_record)
    should_alert = alert_decision_branch(json_record)

    # Load and notification
    load_mahidol_aqi_postgres(record=json_record, is_duplicate=is_duplicate)
    notify_pm25_email(record=json_record, send_alert=should_alert)


# ----------------------------------------------------------------------
# Entry point for Dagster CLI / UI
# ----------------------------------------------------------------------


if __name__ == "__main__":
    # This block allows the job to be executed directly via `python <script>.py`
    from dagster import execute_job

    result = execute_job(pm2_5_risk_alert_pipeline)
    assert result.success
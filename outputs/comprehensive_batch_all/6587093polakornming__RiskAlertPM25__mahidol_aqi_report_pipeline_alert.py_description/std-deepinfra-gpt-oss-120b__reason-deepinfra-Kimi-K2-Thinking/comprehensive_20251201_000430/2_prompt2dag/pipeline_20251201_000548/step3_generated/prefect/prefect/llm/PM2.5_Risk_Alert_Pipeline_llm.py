# Generated by Prefect Pipeline Generator
# Date: 2024-06-28
# Pipeline: PM2.5_Risk_Alert_Pipeline
# Description: Comprehensive Pipeline Description
# Prefect version: 2.14.0

from __future__ import annotations

import json
import smtplib
import ssl
from email.message import EmailMessage
from typing import Any, Dict

import requests
from prefect import flow, task, get_run_logger
from prefect.task_runners import SequentialTaskRunner
from prefect.blocks.system import Secret
from prefect.blocks.core import Block
from prefect.deployments import Deployment
from prefect.orion.schemas.schedules import IntervalSchedule

# -------------------------------------------------------------------------
# Helper functions to load Prefect blocks
# -------------------------------------------------------------------------

def get_secret(name: str) -> str:
    """Retrieve a secret value from a Prefect Secret block."""
    secret_block = Secret.load(name)
    return secret_block.get()


# -------------------------------------------------------------------------
# Tasks
# -------------------------------------------------------------------------

@task(retries=0, name="Extract Mahidol AQI HTML")
def extract_mahidol_aqi_html() -> str:
    """
    Fetch the AQI HTML page from the Mahidol University website.

    Returns:
        str: Raw HTML content.
    """
    logger = get_run_logger()
    try:
        url = get_secret("mahidol_aqi_website")
        logger.info("Fetching AQI data from %s", url)
        response = requests.get(url, timeout=30)
        response.raise_for_status()
        logger.debug("Received %d bytes of HTML", len(response.text))
        return response.text
    except Exception as exc:
        logger.error("Failed to fetch AQI HTML: %s", exc)
        raise


@task(retries=0, name="Transform Mahidol AQI to JSON")
def transform_mahidol_aqi_json(html: str) -> Dict[str, Any]:
    """
    Parse the raw HTML and convert the AQI data into a JSON‑compatible dict.

    Args:
        html: Raw HTML string from the AQI website.

    Returns:
        dict: Structured AQI data.
    """
    logger = get_run_logger()
    try:
        # Placeholder parsing logic – replace with real BeautifulSoup parsing.
        # For demonstration we assume the HTML contains a JSON snippet.
        start = html.find("{")
        end = html.rfind("}") + 1
        json_str = html[start:end]
        data = json.loads(json_str)
        logger.info("Transformed HTML to JSON with %d keys", len(data))
        return data
    except Exception as exc:
        logger.error("Failed to transform HTML to JSON: %s", exc)
        raise


@task(retries=0, name="Duplicate Check Branch")
def duplicate_check_branch(aqi_data: Dict[str, Any]) -> bool:
    """
    Determine whether the incoming AQI record already exists in the warehouse.

    Args:
        aqi_data: Parsed AQI data.

    Returns:
        bool: ``True`` if the record is a duplicate, ``False`` otherwise.
    """
    logger = get_run_logger()
    try:
        # Simple duplicate logic: check if a record with the same timestamp exists.
        # In a real implementation this would query PostgreSQL.
        timestamp = aqi_data.get("timestamp")
        if not timestamp:
            logger.warning("No timestamp found in AQI data; assuming not duplicate.")
            return False

        # Placeholder: pretend we queried the DB and found no duplicate.
        logger.info("Checked for duplicate record at timestamp %s – not found.", timestamp)
        return False
    except Exception as exc:
        logger.error("Duplicate check failed: %s", exc)
        raise


@task(retries=0, name="Load Mahidol AQI into PostgreSQL")
def load_mahidol_aqi_postgres(aqi_data: Dict[str, Any]) -> None:
    """
    Insert the AQI JSON payload into the PostgreSQL data warehouse.

    Args:
        aqi_data: Parsed AQI data.
    """
    logger = get_run_logger()
    try:
        conn_str = get_secret("postgres_warehouse")
        logger.info("Connecting to PostgreSQL warehouse.")
        # Using psycopg2 for demonstration; in production use async or SQLAlchemy.
        import psycopg2
        with psycopg2.connect(conn_str) as conn:
            with conn.cursor() as cur:
                insert_sql = """
                INSERT INTO aqi_measurements (timestamp, data)
                VALUES (%s, %s)
                """
                cur.execute(insert_sql, (aqi_data["timestamp"], json.dumps(aqi_data)))
                conn.commit()
        logger.info("Successfully loaded AQI data for %s into PostgreSQL.", aqi_data["timestamp"])
    except Exception as exc:
        logger.error("Failed to load AQI data into PostgreSQL: %s", exc)
        raise


@task(retries=0, name="Alert Decision Branch")
def alert_decision_branch(aqi_data: Dict[str, Any]) -> bool:
    """
    Decide whether the current AQI measurement warrants an email alert.

    Args:
        aqi_data: Parsed AQI data.

    Returns:
        bool: ``True`` if an alert should be sent, ``False`` otherwise.
    """
    logger = get_run_logger()
    try:
        pm25 = aqi_data.get("pm25")
        if pm25 is None:
            logger.warning("PM2.5 value missing; cannot make alert decision.")
            return False

        # Example threshold – adjust as needed.
        threshold = 35.0
        alert = pm25 >= threshold
        logger.info("PM2.5 = %.2f µg/m³ – Alert needed: %s", pm25, alert)
        return alert
    except Exception as exc:
        logger.error("Alert decision failed: %s", exc)
        raise


@task(retries=0, name="Notify PM2.5 Email Alert")
def notify_pm25_email(aqi_data: Dict[str, Any]) -> None:
    """
    Send an email notification when PM2.5 exceeds the defined threshold.

    Args:
        aqi_data: Parsed AQI data that triggered the alert.
    """
    logger = get_run_logger()
    try:
        smtp_server = get_secret("smtp_gmail")
        smtp_user = get_secret("smtp_gmail_user")
        smtp_password = get_secret("smtp_gmail_password")
        recipient = get_secret("alert_recipient_email")

        subject = f"PM2.5 Alert – {aqi_data.get('timestamp')}"
        body = f"""\
        Alert triggered for PM2.5 concentration.

        Timestamp: {aqi_data.get('timestamp')}
        PM2.5: {aqi_data.get('pm25')} µg/m³

        Please take appropriate actions.
        """

        message = EmailMessage()
        message["From"] = smtp_user
        message["To"] = recipient
        message["Subject"] = subject
        message.set_content(body)

        context = ssl.create_default_context()
        logger.info("Sending alert email to %s via %s", recipient, smtp_server)
        with smtplib.SMTP_SSL(smtp_server, 465, context=context) as server:
            server.login(smtp_user, smtp_password)
            server.send_message(message)

        logger.info("Alert email sent successfully.")
    except Exception as exc:
        logger.error("Failed to send alert email: %s", exc)
        raise


# -------------------------------------------------------------------------
# Flow definition
# -------------------------------------------------------------------------

@flow(
    name="PM2.5_Risk_Alert_Pipeline",
    description="Comprehensive Pipeline Description",
    task_runner=SequentialTaskRunner(),
)
def pm2_5_risk_alert_pipeline() -> None:
    """
    Orchestrates the end‑to‑end PM2.5 risk alert workflow.

    Steps:
        1. Extract raw HTML from Mahidol AQI website.
        2. Transform HTML into structured JSON.
        3. Check for duplicate records.
        4. Load new data into PostgreSQL.
        5. Decide whether an alert is required.
        6. Send an email notification if needed.
    """
    logger = get_run_logger()

    # Step 1: Extraction
    html = extract_mahidol_aqi_html()

    # Step 2: Transformation
    aqi_json = transform_mahidol_aqi_json(html)

    # Step 3: Duplicate check (branch)
    is_duplicate = duplicate_check_branch(aqi_json)

    if not is_duplicate:
        # Step 4: Load into warehouse
        load_mahidol_aqi_postgres(aqi_json)
    else:
        logger.info("Duplicate record detected – skipping load step.")

    # Step 5: Alert decision (branch)
    should_alert = alert_decision_branch(aqi_json)

    if should_alert:
        # Step 6: Notification
        notify_pm25_email(aqi_json)
    else:
        logger.info("No alert condition met – email not sent.")


# -------------------------------------------------------------------------
# Deployment (optional – for reference)
# -------------------------------------------------------------------------

def build_deployment() -> Deployment:
    """
    Build a Prefect deployment for the pipeline.

    The deployment is disabled by default (schedule=None) as per the
    specification.
    """
    return Deployment.build_from_flow(
        flow=pm2_5_risk_alert_pipeline,
        name="pm2.5_risk_alert_pipeline_deployment",
        work_pool_name="default-agent-pool",
        schedule=None,  # Disabled schedule
        flow_name="pm2.5_risk_alert_pipeline",
        parameters={},
        tags=[],
    )


if __name__ == "__main__":
    # Running the flow directly (useful for local testing)
    pm2_5_risk_alert_pipeline()
# Generated by Prefect Pipeline Generator on 2024-06-28
# Pipeline: PM2.5_Risk_Alert_Pipeline
# Description: Comprehensive Pipeline Description
# Prefect version: 2.14.0

from datetime import datetime, timezone, timedelta
import json
import os
import smtplib
from email.message import EmailMessage

import requests
from bs4 import BeautifulSoup

from prefect import flow, task, get_run_logger
from prefect.task_runners import SequentialTaskRunner
from prefect.blocks.system import Secret
from prefect.filesystems import LocalFileSystem
from prefect_sqlalchemy import PostgreSQLConnector
from prefect_email import SMTPServer

# ----------------------------------------------------------------------
# Helper functions
# ----------------------------------------------------------------------


def _load_secret(secret_name: str) -> str:
    """Load a secret value from a Prefect Secret block."""
    secret = Secret.load(secret_name)
    return secret.get()


def _load_filesystem(block_name: str) -> LocalFileSystem:
    """Load a Prefect LocalFileSystem block."""
    return LocalFileSystem.load(block_name)


def _load_postgres(block_name: str) -> PostgreSQLConnector:
    """Load a Prefect PostgreSQLConnector block."""
    return PostgreSQLConnector.load(block_name)


def _load_smtp(block_name: str) -> SMTPServer:
    """Load a Prefect SMTPServer block."""
    return SMTPServer.load(block_name)


# ----------------------------------------------------------------------
# Tasks
# ----------------------------------------------------------------------


@task(retries=0, name="Extract Mahidol AQI HTML")
def extract_mahidol_aqi_html() -> str:
    """
    Retrieve the raw HTML page from the Mahidol University AQI website.

    Returns
    -------
    str
        The HTML content as a string.
    """
    logger = get_run_logger()
    api_url = _load_secret("mahidol_aqi_api")
    logger.info("Fetching AQI HTML from %s", api_url)

    try:
        response = requests.get(api_url, timeout=30)
        response.raise_for_status()
        logger.debug("Received %d bytes of HTML", len(response.text))
        return response.text
    except Exception as exc:
        logger.error("Failed to fetch AQI HTML: %s", exc)
        raise


@task(retries=0, name="Transform Mahidol AQI to JSON")
def transform_mahidol_aqi_json(html: str) -> dict:
    """
    Parse the AQI HTML and convert the relevant data to a JSON‑compatible dict.

    Parameters
    ----------
    html : str
        Raw HTML content fetched from the AQI website.

    Returns
    -------
    dict
        Parsed AQI data, e.g. {"timestamp": "...", "pm25": 42.0, ...}
    """
    logger = get_run_logger()
    logger.info("Transforming HTML to JSON")

    try:
        soup = BeautifulSoup(html, "html.parser")
        # Example parsing logic – adapt to actual page structure
        timestamp_str = soup.find("span", {"id": "aqi-timestamp"}).text.strip()
        pm25_str = soup.find("div", {"class": "pm25-value"}).text.strip()

        timestamp = datetime.strptime(timestamp_str, "%Y-%m-%d %H:%M").replace(
            tzinfo=timezone.utc
        )
        pm25 = float(pm25_str)

        data = {"timestamp": timestamp.isoformat(), "pm25": pm25}
        logger.debug("Parsed data: %s", data)
        return data
    except Exception as exc:
        logger.error("Error parsing AQI HTML: %s", exc)
        raise


@task(retries=0, name="Data Freshness Branch")
def data_freshness_branch(aqi_data: dict, freshness_limit_minutes: int = 60) -> bool:
    """
    Determine whether the AQI data is fresh enough to be loaded.

    Parameters
    ----------
    aqi_data : dict
        The parsed AQI data containing a ``timestamp`` key.
    freshness_limit_minutes : int, optional
        Maximum age of data in minutes. Default is 60.

    Returns
    -------
    bool
        ``True`` if data is fresh, ``False`` otherwise.
    """
    logger = get_run_logger()
    timestamp = datetime.fromisoformat(aqi_data["timestamp"])
    age = datetime.now(timezone.utc) - timestamp
    is_fresh = age <= timedelta(minutes=freshness_limit_minutes)
    logger.info(
        "Data age: %s (freshness limit: %d minutes) → %s",
        age,
        freshness_limit_minutes,
        "fresh" if is_fresh else "stale",
    )
    return is_fresh


@task(retries=0, name="AQI Threshold Branch")
def aqi_threshold_branch(aqi_data: dict, pm25_threshold: float = 35.0) -> bool:
    """
    Check whether the PM2.5 value exceeds a predefined threshold.

    Parameters
    ----------
    aqi_data : dict
        The parsed AQI data containing a ``pm25`` key.
    pm25_threshold : float, optional
        Threshold for PM2.5 concentration. Default is 35.0 µg/m³.

    Returns
    -------
    bool
        ``True`` if the threshold is exceeded, ``False`` otherwise.
    """
    logger = get_run_logger()
    pm25 = aqi_data["pm25"]
    exceeds = pm25 > pm25_threshold
    logger.info(
        "PM2.5 value: %.2f µg/m³ (threshold: %.2f) → %s",
        pm25,
        pm25_threshold,
        "exceeds" if exceeds else "within limits",
    )
    return exceeds


@task(retries=0, name="Load Mahidol AQI into PostgreSQL")
def load_mahidol_aqi_postgres(aqi_data: dict) -> None:
    """
    Insert the AQI record into a PostgreSQL data warehouse.

    Parameters
    ----------
    aqi_data : dict
        The parsed AQI data to be persisted.
    """
    logger = get_run_logger()
    logger.info("Loading AQI data into PostgreSQL")

    try:
        pg_block = _load_postgres("postgres_warehouse")
        engine = pg_block.get_engine()
        insert_sql = """
            INSERT INTO aqi_measurements (timestamp, pm25)
            VALUES (:timestamp, :pm25)
            ON CONFLICT (timestamp) DO UPDATE SET pm25 = EXCLUDED.pm25;
        """
        with engine.begin() as conn:
            conn.execute(
                insert_sql,
                {"timestamp": aqi_data["timestamp"], "pm25": aqi_data["pm25"]},
            )
        logger.info("AQI data successfully persisted")
    except Exception as exc:
        logger.error("Failed to load AQI data into PostgreSQL: %s", exc)
        raise


@task(retries=0, name="Notify PM2.5 Email Alert")
def notify_pm25_email_alert(aqi_data: dict) -> None:
    """
    Send an email alert when PM2.5 exceeds the configured threshold.

    Parameters
    ----------
    aqi_data : dict
        The parsed AQI data used to compose the alert.
    """
    logger = get_run_logger()
    logger.info("Sending PM2.5 alert email")

    try:
        smtp_block = _load_smtp("smtp_gmail")
        smtp_server = smtp_block.get_server()
        smtp_port = smtp_block.get_port()
        username = smtp_block.get_username()
        password = smtp_block.get_password()

        msg = EmailMessage()
        msg["Subject"] = "PM2.5 Alert – Threshold Exceeded"
        msg["From"] = username
        msg["To"] = username  # Sending to self; adjust as needed
        msg.set_content(
            f"""\
Alert generated at {aqi_data['timestamp']}.

Current PM2.5 concentration: {aqi_data['pm25']} µg/m³
This exceeds the configured threshold.
"""
        )

        with smtplib.SMTP_SSL(smtp_server, smtp_port) as server:
            server.login(username, password)
            server.send_message(msg)

        logger.info("Alert email sent successfully")
    except Exception as exc:
        logger.error("Failed to send alert email: %s", exc)
        raise


# ----------------------------------------------------------------------
# Flow definition
# ----------------------------------------------------------------------


@flow(
    name="pm2.5_risk_alert_pipeline",
    description="Comprehensive Pipeline Description",
    task_runner=SequentialTaskRunner(),
)
def pm2_5_risk_alert_pipeline() -> None:
    """
    Orchestrates the end‑to‑end PM2.5 risk alert workflow.

    Steps
    -----
    1. Extract raw HTML from Mahidol AQI website.
    2. Transform HTML into structured JSON.
    3. Evaluate data freshness and AQI threshold branches.
    4. Conditionally load fresh data into PostgreSQL.
    5. Conditionally send an email alert when thresholds are exceeded.
    """
    logger = get_run_logger()
    logger.info("Starting PM2.5 Risk Alert Pipeline")

    # Extraction
    html = extract_mahidol_aqi_html()

    # Transformation
    aqi_json = transform_mahidol_aqi_json(html)

    # Branch evaluations
    is_fresh = data_freshness_branch(aqi_json)
    exceeds_threshold = aqi_threshold_branch(aqi_json)

    # Conditional downstream tasks
    if is_fresh:
        load_mahidol_aqi_postgres(aqi_json)
    else:
        logger.warning("Data is stale – skipping PostgreSQL load")

    if exceeds_threshold:
        notify_pm25_email_alert(aqi_json)
    else:
        logger.info("PM2.5 within safe limits – no email sent")

    logger.info("PM2.5 Risk Alert Pipeline completed")


# ----------------------------------------------------------------------
# Entry point for local execution
# ----------------------------------------------------------------------
if __name__ == "__main__":
    pm2_5_risk_alert_pipeline()
# Generated by Dagster Code Generator
# Date: 2024-06-20
# Pipeline: analyze_transactions_pipeline
# Description: Comprehensive Pipeline Description
# Pattern: fanout_fanin

from typing import List, Dict, Any

from dagster import (
    op,
    job,
    In,
    Out,
    RetryPolicy,
    ConfigurableResource,
    ResourceDefinition,
    IOManager,
    fs_io_manager,
    multiprocess_executor,
    ScheduleDefinition,
    DefaultScheduleStatus,
    Definitions,
)


# ----------------------------------------------------------------------
# Resource Definitions
# ----------------------------------------------------------------------


class ManualReviewQueueResource(ConfigurableResource):
    """Placeholder resource for a manual review queue."""

    def enqueue(self, transaction: Dict[str, Any]) -> None:
        """Enqueue a transaction for manual review."""
        # Implement actual enqueue logic here
        pass


class PaymentProcessingAPIResource(ConfigurableResource):
    """Placeholder resource for interacting with a payment processing API."""

    def approve(self, transaction: Dict[str, Any]) -> None:
        """Approve a transaction via the payment processing system."""
        # Implement actual approval logic here
        pass


class NotificationEmailResource(ConfigurableResource):
    """Placeholder resource for sending fraud detection notification emails."""

    def send(self, subject: str, body: str) -> None:
        """Send an email notification."""
        # Implement actual email sending logic here
        pass


# ----------------------------------------------------------------------
# Op Definitions
# ----------------------------------------------------------------------


@op(
    name="analyze_transactions",
    description="Read daily transaction CSV files and produce a list of transaction dicts.",
    out=Out(List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def analyze_transactions(context) -> List[Dict[str, Any]]:
    """
    Load transaction data from CSV files stored via the ``fs_io_manager``.
    This op returns a list of transaction dictionaries for downstream processing.
    """
    # Example placeholder logic: read a CSV file from the filesystem.
    # In a real implementation, you would use context.resources.fs_io_manager
    # to locate and read the daily CSV files.
    import csv
    import os

    transactions: List[Dict[str, Any]] = []
    data_dir = os.getenv("TRANSACTION_DATA_DIR", "./data")
    for filename in os.listdir(data_dir):
        if filename.endswith(".csv"):
            file_path = os.path.join(data_dir, filename)
            with open(file_path, newline="") as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    transactions.append(row)
    context.log.info(f"Loaded {len(transactions)} transactions.")
    return transactions


@op(
    name="route_transaction",
    description="Determine routing for each transaction (auto‑approve or manual review).",
    ins={"transactions": In(List[Dict[str, Any]])},
    out=Out(Dict[str, List[Dict[str, Any]]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def route_transaction(context, transactions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """
    Simple routing logic:
    - If ``amount`` < 1000 → auto‑approve.
    - Otherwise → manual review.
    Returns a dict with keys ``auto`` and ``manual``.
    """
    auto: List[Dict[str, Any]] = []
    manual: List[Dict[str, Any]] = []

    for txn in transactions:
        try:
            amount = float(txn.get("amount", 0))
        except ValueError:
            amount = 0

        if amount < 1000:
            auto.append(txn)
        else:
            manual.append(txn)

    context.log.info(f"Routing result – auto: {len(auto)}, manual: {len(manual)}")
    return {"auto": auto, "manual": manual}


@op(
    name="route_to_auto_approve",
    description="Approve transactions automatically via the payment processing API.",
    ins={"auto_transactions": In(List[Dict[str, Any]])},
    out=Out(List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def route_to_auto_approve(context, auto_transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Calls the payment processing API for each auto‑approved transaction.
    Returns the list of successfully approved transactions.
    """
    approved: List[Dict[str, Any]] = []
    api: PaymentProcessingAPIResource = context.resources.payment_processing_api

    for txn in auto_transactions:
        try:
            api.approve(txn)
            approved.append(txn)
        except Exception as exc:  # pragma: no cover
            context.log.error(f"Failed to auto‑approve transaction {txn.get('id')}: {exc}")

    context.log.info(f"Auto‑approved {len(approved)} transactions.")
    return approved


@op(
    name="route_to_manual_review",
    description="Enqueue transactions that require manual review.",
    ins={"manual_transactions": In(List[Dict[str, Any]])},
    out=Out(List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def route_to_manual_review(context, manual_transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Sends each transaction needing manual review to the manual review queue.
    Returns the list of enqueued transactions.
    """
    queue: ManualReviewQueueResource = context.resources.manual_review_queue
    enqueued: List[Dict[str, Any]] = []

    for txn in manual_transactions:
        try:
            queue.enqueue(txn)
            enqueued.append(txn)
        except Exception as exc:  # pragma: no cover
            context.log.error(f"Failed to enqueue transaction {txn.get('id')}: {exc}")

    context.log.info(f"Enqueued {len(enqueued)} transactions for manual review.")
    return enqueued


@op(
    name="send_notification",
    description="Send a notification email summarizing routing outcomes.",
    ins={
        "auto_results": In(List[Dict[str, Any]]),
        "manual_results": In(List[Dict[str, Any]]),
    },
    out=Out(bool),
    retry_policy=RetryPolicy(max_retries=2),
)
def send_notification(
    context,
    auto_results: List[Dict[str, Any]],
    manual_results: List[Dict[str, Any]],
) -> bool:
    """
    Sends a summary email using the ``notification_email`` resource.
    Returns ``True`` if the email was sent successfully.
    """
    email: NotificationEmailResource = context.resources.notification_email
    subject = "Daily Transaction Routing Summary"
    body = (
        f"Auto‑approved transactions: {len(auto_results)}\n"
        f"Transactions sent for manual review: {len(manual_results)}"
    )
    try:
        email.send(subject=subject, body=body)
        context.log.info("Notification email sent.")
        return True
    except Exception as exc:  # pragma: no cover
        context.log.error(f"Failed to send notification email: {exc}")
        return False


# ----------------------------------------------------------------------
# Job Definition
# ----------------------------------------------------------------------


@job(
    name="analyze_transactions_pipeline",
    description="Comprehensive Pipeline Description",
    executor_def=multiprocess_executor,
    resource_defs={
        "fs_io_manager": fs_io_manager,
        "manual_review_queue": ManualReviewQueueResource(),
        "payment_processing_api": PaymentProcessingAPIResource(),
        "notification_email": NotificationEmailResource(),
    },
    config=None,
)
def analyze_transactions_pipeline():
    """
    Orchestrates the transaction analysis workflow:
    1. Load and analyze raw transaction CSV files.
    2. Route each transaction to either auto‑approval or manual review.
    3. Process auto‑approved transactions via the payment API.
    4. Enqueue manual‑review transactions.
    5. Send a summary notification email.
    """
    transactions = analyze_transactions()
    routing = route_transaction(transactions)

    auto_approved = route_to_auto_approve(routing["auto"])
    manual_enqueued = route_to_manual_review(routing["manual"])

    send_notification(auto_results=auto_approved, manual_results=manual_enqueued)


# ----------------------------------------------------------------------
# Schedule Definition
# ----------------------------------------------------------------------


daily_schedule = ScheduleDefinition(
    job=analyze_transactions_pipeline,
    cron_schedule="@daily",
    execution_timezone="UTC",
    default_status=DefaultScheduleStatus.RUNNING,
    description="Daily execution of the transaction analysis pipeline.",
)


# ----------------------------------------------------------------------
# Definitions Export
# ----------------------------------------------------------------------


defs = Definitions(
    jobs=[analyze_transactions_pipeline],
    schedules=[daily_schedule],
    resources={
        "fs_io_manager": fs_io_manager,
        "manual_review_queue": ManualReviewQueueResource(),
        "payment_processing_api": PaymentProcessingAPIResource(),
        "notification_email": NotificationEmailResource(),
    },
)
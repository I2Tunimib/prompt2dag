# Generated by Prefect Pipeline Generator
# Date: 2024-06-28
# Pipeline: fraud_detection_triage
# Description: No description provided.
# Pattern: fanout_fanin
# Prefect version: 2.14.0

from __future__ import annotations

import json
import pathlib
from typing import List, Dict, Any

from prefect import flow, task, get_run_logger
from prefect.task_runners import ConcurrentTaskRunner
from prefect.filesystems import LocalFileSystem
from prefect.blocks.system import Secret


# -------------------------------------------------------------------------
# Block loading (connections / resources)
# -------------------------------------------------------------------------
transaction_fs: LocalFileSystem = LocalFileSystem.load("transaction_csv_files")
manual_review_queue: Secret = Secret.load("manual_review_queue")
payment_processing_api: Secret = Secret.load("payment_processing_api")
notification_service: Secret = Secret.load("notification_service")


# -------------------------------------------------------------------------
# Helper functions
# -------------------------------------------------------------------------
def _load_csv_paths() -> List[pathlib.Path]:
    """
    Retrieve all CSV file paths from the configured LocalFileSystem block.
    """
    logger = get_run_logger()
    try:
        base_path = pathlib.Path(transaction_fs.base_path)
        csv_files = list(base_path.rglob("*.csv"))
        logger.info("Found %d CSV files in %s", len(csv_files), base_path)
        return csv_files
    except Exception as exc:
        logger.error("Failed to list CSV files: %s", exc)
        raise


def _read_csv(file_path: pathlib.Path) -> List[Dict[str, Any]]:
    """
    Very lightweight CSV reader that returns a list of dict rows.
    """
    import csv

    logger = get_run_logger()
    try:
        with file_path.open(newline="") as f:
            reader = csv.DictReader(f)
            rows = [row for row in reader]
        logger.info("Read %d rows from %s", len(rows), file_path.name)
        return rows
    except Exception as exc:
        logger.error("Error reading %s: %s", file_path.name, exc)
        raise


# -------------------------------------------------------------------------
# Tasks
# -------------------------------------------------------------------------
@task(retries=2, retry_delay_seconds=10)
def analyze_transactions() -> List[Dict[str, Any]]:
    """
    Load daily transaction CSV files and compute a simple risk score for each transaction.
    Returns a list of enriched transaction dictionaries.
    """
    logger = get_run_logger()
    enriched_transactions: List[Dict[str, Any]] = []

    csv_paths = _load_csv_paths()
    for path in csv_paths:
        rows = _read_csv(path)
        for row in rows:
            # Example risk calculation (placeholder)
            amount = float(row.get("amount", 0))
            risk_score = min(1.0, amount / 10_000)  # simplistic risk metric
            row["risk_score"] = risk_score
            enriched_transactions.append(row)

    logger.info("Analyzed %d transactions", len(enriched_transactions))
    return enriched_transactions


@task(retries=2, retry_delay_seconds=10)
def route_transaction(
    transactions: List[Dict[str, Any]],
) -> Dict[str, List[Dict[str, Any]]]:
    """
    Split transactions into two buckets:
    - auto_approve: risk_score < 0.2
    - manual_review: risk_score >= 0.2
    Returns a dict with keys ``auto_approve`` and ``manual_review``.
    """
    logger = get_run_logger()
    auto_approve: List[Dict[str, Any]] = []
    manual_review: List[Dict[str, Any]] = []

    for txn in transactions:
        if txn.get("risk_score", 0) < 0.2:
            auto_approve.append(txn)
        else:
            manual_review.append(txn)

    logger.info(
        "Routing complete: %d auto‑approve, %d manual‑review",
        len(auto_approve),
        len(manual_review),
    )
    return {"auto_approve": auto_approve, "manual_review": manual_review}


@task(retries=2, retry_delay_seconds=10)
def process_auto_approve(transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Send auto‑approved transactions to the payment processing API.
    Returns the list of successfully processed transactions.
    """
    logger = get_run_logger()
    api_credentials = json.loads(payment_processing_api.get())
    # Placeholder for actual API call
    processed: List[Dict[str, Any]] = []

    for txn in transactions:
        try:
            # Simulated API interaction
            logger.debug(
                "Approving transaction %s via API %s",
                txn.get("transaction_id"),
                api_credentials.get("endpoint"),
            )
            # Assume success
            txn["status"] = "approved"
            processed.append(txn)
        except Exception as exc:
            logger.error(
                "Failed to approve transaction %s: %s", txn.get("transaction_id"), exc
            )
            # In a real implementation you might raise or continue based on policy

    logger.info("Auto‑approved %d transactions", len(processed))
    return processed


@task(retries=2, retry_delay_seconds=10)
def process_manual_review(transactions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Enqueue transactions that require manual review.
    Returns the list of enqueued transactions.
    """
    logger = get_run_logger()
    queue_name = manual_review_queue.get()
    enqueued: List[Dict[str, Any]] = []

    for txn in transactions:
        try:
            # Placeholder for queue interaction
            logger.debug(
                "Enqueuing transaction %s to queue %s",
                txn.get("transaction_id"),
                queue_name,
            )
            txn["status"] = "queued_for_review"
            enqueued.append(txn)
        except Exception as exc:
            logger.error(
                "Failed to enqueue transaction %s: %s", txn.get("transaction_id"), exc
            )

    logger.info("Queued %d transactions for manual review", len(enqueued))
    return enqueued


@task(retries=2, retry_delay_seconds=10)
def send_notification(
    auto_approved: List[Dict[str, Any]],
    manual_reviewed: List[Dict[str, Any]],
) -> None:
    """
    Send a summary notification to the fraud detection notification service.
    """
    logger = get_run_logger()
    service_config = json.loads(notification_service.get())

    summary = {
        "auto_approved_count": len(auto_approved),
        "manual_review_count": len(manual_reviewed),
    }

    try:
        # Placeholder for actual notification call
        logger.debug(
            "Sending notification to %s with payload %s",
            service_config.get("endpoint"),
            summary,
        )
        # Assume success
        logger.info("Notification sent successfully")
    except Exception as exc:
        logger.error("Failed to send notification: %s", exc)
        raise


# -------------------------------------------------------------------------
# Flow definition
# -------------------------------------------------------------------------
@flow(
    name="fraud_detection_triage",
    task_runner=ConcurrentTaskRunner(),
)
def fraud_detection_triage_flow() -> None:
    """
    End‑to‑end fraud detection triage pipeline.

    1. Analyze raw transaction CSV files.
    2. Route each transaction to either auto‑approval or manual review.
    3. Process auto‑approved transactions via the payment API.
    4. Queue manual‑review transactions.
    5. Send a summary notification.
    """
    logger = get_run_logger()

    # Step 1: Analyze
    analyzed = analyze_transactions()

    # Step 2: Routing (fan‑out)
    routed = route_transaction(analyzed)

    # Step 3: Parallel processing (fan‑out)
    auto_approved = process_auto_approve(routed["auto_approve"])
    manual_reviewed = process_manual_review(routed["manual_review"])

    # Step 4: Fan‑in – send notification after both branches complete
    send_notification(auto_approved, manual_reviewed)

    logger.info("Fraud detection triage flow completed")


# -------------------------------------------------------------------------
# Entry point for local execution
# -------------------------------------------------------------------------
if __name__ == "__main__":
    fraud_detection_triage_flow()
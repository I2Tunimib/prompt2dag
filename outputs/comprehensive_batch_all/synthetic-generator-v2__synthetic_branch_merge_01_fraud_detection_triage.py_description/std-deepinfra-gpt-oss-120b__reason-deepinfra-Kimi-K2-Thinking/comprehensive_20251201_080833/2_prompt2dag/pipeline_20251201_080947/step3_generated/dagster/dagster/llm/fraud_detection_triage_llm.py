# Generated by Dagster code generator
# Date: 2024-06-28
# Pipeline: fraud_detection_triage
# Description: No description provided.
# Executor: multiprocess_executor
# Dagster version: 1.5.0

from __future__ import annotations

from typing import List, Dict, Any

import pandas as pd
from dagster import (
    op,
    job,
    In,
    Out,
    RetryPolicy,
    ResourceDefinition,
    ConfigurableResource,
    InitResourceContext,
    get_dagster_logger,
    multiprocess_executor,
    fs_io_manager,
    ScheduleDefinition,
    DefaultScheduleStatus,
)


# -------------------------------------------------------------------------
# Resource definitions
# -------------------------------------------------------------------------

class ManualReviewQueue(ConfigurableResource):
    """Placeholder resource for a manual review queue."""

    def enqueue(self, transaction: Dict[str, Any]) -> None:
        """Enqueue a transaction for manual review."""
        logger = get_dagster_logger()
        logger.info(f"Enqueued transaction for manual review: {transaction['transaction_id']}")


class PaymentProcessingAPI(ConfigurableResource):
    """Placeholder resource for a payment processing API."""

    def approve(self, transaction: Dict[str, Any]) -> None:
        """Approve a transaction automatically."""
        logger = get_dagster_logger()
        logger.info(f"Automatically approved transaction: {transaction['transaction_id']}")


class NotificationService(ConfigurableResource):
    """Placeholder resource for sending notifications."""

    def send(self, message: str) -> None:
        """Send a notification message."""
        logger = get_dagster_logger()
        logger.info(f"Notification sent: {message}")


# -------------------------------------------------------------------------
# Ops
# -------------------------------------------------------------------------

@op(
    name="analyze_transactions",
    description="Read daily transaction CSV files and perform basic fraud analysis.",
    out=Out(List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def analyze_transactions(context: InitResourceContext) -> List[Dict[str, Any]]:
    """
    Load transaction data from CSV files stored via the ``fs_io_manager`` and
    produce a list of transaction dictionaries enriched with a simple fraud score.
    """
    logger = get_dagster_logger()
    # The fs_io_manager provides a handle to the filesystem; we assume CSV files are
    # located under a known directory.
    io_manager = context.resources.fs_io_manager
    # For demonstration we read a single CSV file; in production this could be a
    # glob of daily files.
    csv_path = "transactions/daily_transactions.csv"
    try:
        df = pd.read_csv(io_manager.get_path(csv_path))
    except FileNotFoundError:
        logger.error(f"Transaction file not found: {csv_path}")
        return []

    # Simple fraud scoring: flag transactions > $10,000 as high risk.
    df["fraud_score"] = df["amount"].apply(lambda amt: "high" if amt > 10_000 else "low")
    transactions = df.to_dict(orient="records")
    logger.info(f"Analyzed {len(transactions)} transactions.")
    return transactions


@op(
    name="route_transaction",
    description="Route each transaction to auto‑approval or manual review based on fraud score.",
    ins={"transactions": In(List[Dict[str, Any]])},
    out=Out(Dict[str, List[Dict[str, Any]]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def route_transaction(context: InitResourceContext, transactions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """
    Split the incoming transaction list into two buckets:
    * ``auto_approve`` – low‑risk transactions
    * ``manual_review`` – high‑risk transactions
    """
    logger = get_dagster_logger()
    auto_approve = []
    manual_review = []

    for txn in transactions:
        if txn.get("fraud_score") == "high":
            manual_review.append(txn)
        else:
            auto_approve.append(txn)

    logger.info(
        f"Routing complete: {len(auto_approve)} auto‑approve, {len(manual_review)} manual review."
    )
    return {"auto_approve": auto_approve, "manual_review": manual_review}


@op(
    name="process_auto_approve",
    description="Automatically approve low‑risk transactions via the payment processing API.",
    ins={"auto_transactions": In(List[Dict[str, Any]])},
    out=Out(List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def process_auto_approve(
    context: InitResourceContext,
    auto_transactions: List[Dict[str, Any]],
) -> List[Dict[str, Any]]:
    """
    Iterate over low‑risk transactions and call the payment processing API to approve them.
    """
    logger = get_dagster_logger()
    api: PaymentProcessingAPI = context.resources.payment_processing_api

    for txn in auto_transactions:
        api.approve(txn)

    logger.info(f"Auto‑approved {len(auto_transactions)} transactions.")
    return auto_transactions


@op(
    name="process_manual_review",
    description="Enqueue high‑risk transactions for manual review.",
    ins={"manual_transactions": In(List[Dict[str, Any]])},
    out=Out(List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def process_manual_review(
    context: InitResourceContext,
    manual_transactions: List[Dict[str, Any]],
) -> List[Dict[str, Any]]:
    """
    Send each high‑risk transaction to the manual review queue.
    """
    logger = get_dagster_logger()
    queue: ManualReviewQueue = context.resources.manual_review_queue

    for txn in manual_transactions:
        queue.enqueue(txn)

    logger.info(f"Queued {len(manual_transactions)} transactions for manual review.")
    return manual_transactions


@op(
    name="send_notification",
    description="Notify stakeholders about the outcome of the fraud triage process.",
    ins={
        "auto_results": In(List[Dict[str, Any]]),
        "manual_results": In(List[Dict[str, Any]]),
    },
    out=Out(None),
    retry_policy=RetryPolicy(max_retries=2),
)
def send_notification(
    context: InitResourceContext,
    auto_results: List[Dict[str, Any]],
    manual_results: List[Dict[str, Any]],
) -> None:
    """
    Build a summary message and send it via the notification service.
    """
    logger = get_dagster_logger()
    notifier: NotificationService = context.resources.notification_service

    message = (
        f"Fraud triage completed. "
        f"Auto‑approved: {len(auto_results)}. "
        f"Sent to manual review: {len(manual_results)}."
    )
    notifier.send(message)
    logger.info("Notification dispatched.")


# -------------------------------------------------------------------------
# Job definition
# -------------------------------------------------------------------------

@job(
    name="fraud_detection_triage",
    description="No description provided.",
    executor_def=multiprocess_executor,
    resource_defs={
        "fs_io_manager": fs_io_manager,
        "manual_review_queue": ResourceDefinition.hardcoded_resource(ManualReviewQueue()),
        "payment_processing_api": ResourceDefinition.hardcoded_resource(PaymentProcessingAPI()),
        "notification_service": ResourceDefinition.hardcoded_resource(NotificationService()),
    },
)
def fraud_detection_triage():
    """
    End‑to‑end fraud detection triage pipeline.

    Execution order (fan‑out/fan‑in pattern):
        analyze_transactions -> route_transaction
        route_transaction -> {process_auto_approve, process_manual_review}
        {process_auto_approve, process_manual_review} -> send_notification
    """
    transactions = analyze_transactions()
    routed = route_transaction(transactions)

    auto_approved = process_auto_approve(routed["auto_approve"])
    manual_reviewed = process_manual_review(routed["manual_review"])

    send_notification(auto_approved, manual_reviewed)


# -------------------------------------------------------------------------
# Schedule (disabled by default)
# -------------------------------------------------------------------------

fraud_detection_triage_schedule = ScheduleDefinition(
    job=fraud_detection_triage,
    cron_schedule="@daily",
    execution_timezone="UTC",
    default_status=DefaultScheduleStatus.INACTIVE,
    description="Daily execution of the fraud detection triage pipeline.",
)
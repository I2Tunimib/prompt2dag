# Generated by Dagster Code Generator
# Date: 2024-06-28
# Dagster version: 1.5.0

from typing import List, Dict, Any

import dagster
from dagster import (
    op,
    job,
    In,
    Out,
    RetryPolicy,
    ResourceDefinition,
    fs_io_manager,
    multiprocess_executor,
    ScheduleDefinition,
    ScheduleStatus,
)


# -------------------------------------------------------------------------
# Resource placeholders
# -------------------------------------------------------------------------

class ManualReviewQueue:
    """Placeholder for a manual review queue resource."""

    def enqueue(self, transaction: Dict[str, Any]) -> None:
        """Enqueue a transaction for manual review."""
        # Implement actual enqueue logic here
        pass


class PaymentProcessingAPI:
    """Placeholder for a payment processing system resource."""

    def approve(self, transaction: Dict[str, Any]) -> None:
        """Automatically approve a transaction."""
        # Implement actual approval logic here
        pass


class NotificationService:
    """Placeholder for a fraud detection notification service."""

    def send(self, message: str) -> None:
        """Send a notification message."""
        # Implement actual notification logic here
        pass


# -------------------------------------------------------------------------
# Ops
# -------------------------------------------------------------------------

@op(
    name="analyze_transactions",
    description="Read daily transaction CSV files and produce a list of transaction records.",
    out=Out(List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def analyze_transactions(context) -> List[Dict[str, Any]]:
    """
    Load transaction data from CSV files stored via the ``fs_io_manager``.
    Returns a list of transaction dictionaries.
    """
    # In a real implementation, you would read CSV files from the filesystem.
    # Here we return a mock list for illustration.
    context.log.info("Analyzing transactions from CSV files.")
    mock_transactions = [
        {"id": "tx1", "amount": 100.0, "risk_score": 0.2},
        {"id": "tx2", "amount": 5000.0, "risk_score": 0.9},
    ]
    return mock_transactions


@op(
    name="route_transaction",
    description="Route transactions to either auto‑approve or manual review based on risk.",
    ins={"transactions": In(List[Dict[str, Any]])},
    out=Out(Dict[str, List[Dict[str, Any]]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def route_transaction(context, transactions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """
    Split transactions into two buckets:
    - ``auto_approve``: low‑risk transactions.
    - ``manual_review``: high‑risk transactions.
    """
    context.log.info("Routing %d transactions.", len(transactions))
    auto_approve = []
    manual_review = []
    for tx in transactions:
        if tx["risk_score"] < 0.5:
            auto_approve.append(tx)
        else:
            manual_review.append(tx)
    return {"auto_approve": auto_approve, "manual_review": manual_review}


@op(
    name="route_to_auto_approve",
    description="Automatically approve low‑risk transactions.",
    ins={"routed": In(Dict[str, List[Dict[str, Any]]])},
    out=Out(List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def route_to_auto_approve(context, routed: Dict[str, List[Dict[str, Any]]]) -> List[Dict[str, Any]]:
    """
    Process the ``auto_approve`` bucket using the payment processing API.
    Returns the list of approved transactions.
    """
    api: PaymentProcessingAPI = context.resources.payment_processing_api
    approved = []
    for tx in routed.get("auto_approve", []):
        api.approve(tx)
        approved.append(tx)
        context.log.info("Auto‑approved transaction %s.", tx["id"])
    return approved


@op(
    name="route_to_manual_review",
    description="Enqueue high‑risk transactions for manual review.",
    ins={"routed": In(Dict[str, List[Dict[str, Any]]])},
    out=Out(List[Dict[str, Any]]),
    retry_policy=RetryPolicy(max_retries=2),
)
def route_to_manual_review(context, routed: Dict[str, List[Dict[str, Any]]]) -> List[Dict[str, Any]]:
    """
    Enqueue the ``manual_review`` bucket into the manual review queue.
    Returns the list of enqueued transactions.
    """
    queue: ManualReviewQueue = context.resources.manual_review_queue
    enqueued = []
    for tx in routed.get("manual_review", []):
        queue.enqueue(tx)
        enqueued.append(tx)
        context.log.info("Enqueued transaction %s for manual review.", tx["id"])
    return enqueued


@op(
    name="send_notification",
    description="Send a notification summarizing the results of the triage.",
    ins={
        "auto_approved": In(List[Dict[str, Any]]),
        "manual_reviewed": In(List[Dict[str, Any]]),
    },
    out=Out(None),
    retry_policy=RetryPolicy(max_retries=2),
)
def send_notification(
    context,
    auto_approved: List[Dict[str, Any]],
    manual_reviewed: List[Dict[str, Any]],
) -> None:
    """
    Notify stakeholders about the number of auto‑approved and manually reviewed transactions.
    """
    notifier: NotificationService = context.resources.notification_service
    message = (
        f"Fraud Detection Triage Summary:\n"
        f"- Auto‑approved: {len(auto_approved)} transactions\n"
        f"- Sent to manual review: {len(manual_reviewed)} transactions"
    )
    notifier.send(message)
    context.log.info("Sent notification: %s", message)


# -------------------------------------------------------------------------
# Job definition
# -------------------------------------------------------------------------

@job(
    name="fraud_detection_triage",
    description="No description provided.",
    executor_def=multiprocess_executor,
    resource_defs={
        "fs_io_manager": fs_io_manager,
        "manual_review_queue": ResourceDefinition.hardcoded_resource(ManualReviewQueue()),
        "payment_processing_api": ResourceDefinition.hardcoded_resource(PaymentProcessingAPI()),
        "notification_service": ResourceDefinition.hardcoded_resource(NotificationService()),
    },
    # The default IO manager is set to the filesystem manager.
    # This aligns with the ``transaction_csv_files`` connection.
    # The job does not use assets, per the orchestrator config.
)
def fraud_detection_triage():
    """
    Orchestrates the fraud detection triage pipeline:
    1. Analyze raw transaction data.
    2. Route each transaction based on risk.
    3. Auto‑approve low‑risk transactions.
    4. Queue high‑risk transactions for manual review.
    5. Send a summary notification.
    """
    transactions = analyze_transactions()
    routed = route_transaction(transactions)

    auto_approved = route_to_auto_approve(routed)
    manual_reviewed = route_to_manual_review(routed)

    send_notification(auto_approved=auto_approved, manual_reviewed=manual_reviewed)


# -------------------------------------------------------------------------
# Schedule definition
# -------------------------------------------------------------------------

fraud_detection_triage_schedule = ScheduleDefinition(
    job=fraud_detection_triage,
    cron_schedule="@daily",
    execution_timezone="UTC",
    default_status=ScheduleStatus.RUNNING,
    description="Daily execution of the fraud detection triage job.",
    # Dagster's schedule does not have a direct ``catchup`` flag; the default
    # behavior aligns with ``catchup=False`` when the schedule is set to RUNNING.
    name="fraud_detection_triage_schedule",
)
# Generated by Prefect Pipeline Generator
# Date: 2024-06-13
# Pipeline: fraud_detection_triage
# Description: Prefect 2.x flow implementing a fan‑out/fan‑in fraud detection triage pipeline.

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import Any, Dict, List

import pandas as pd
from prefect import flow, task
from prefect.blocks.system import Secret
from prefect.filesystems import LocalFileSystem
from prefect.task_runners import ConcurrentTaskRunner
from prefect.deployments import DeploymentSpec
from prefect.orion.schemas.schedules import CronSchedule

logger = logging.getLogger(__name__)


@task(retries=2, retry_delay_seconds=30, name="Analyze Transactions")
def analyze_transactions(csv_path: str) -> List[Dict[str, Any]]:
    """
    Load the daily transaction CSV file and perform basic fraud analysis.

    Args:
        csv_path: Absolute path to the CSV file containing transactions.

    Returns:
        A list of dictionaries, each representing a transaction enriched with an
        ``is_fraud`` flag based on simple heuristic rules.
    """
    logger.info("Reading transaction file from %s", csv_path)

    if not Path(csv_path).exists():
        raise FileNotFoundError(f"Transaction file not found: {csv_path}")

    df = pd.read_csv(csv_path)

    # Example heuristic: flag transactions > $10,000 as potential fraud
    df["is_fraud"] = df["amount"] > 10_000

    transactions = df.to_dict(orient="records")
    logger.info("Analyzed %d transactions, %d flagged as fraud",
                len(transactions), sum(t["is_fraud"] for t in transactions))
    return transactions


@task(retries=2, retry_delay_seconds=30, name="Route Transaction")
def route_transaction(
    transactions: List[Dict[str, Any]]
) -> Dict[str, List[Dict[str, Any]]]:
    """
    Split transactions into two streams based on the fraud flag.

    - ``auto``: Non‑fraudulent transactions that can be auto‑approved.
    - ``manual``: Potentially fraudulent transactions that require manual review.

    Args:
        transactions: List of transaction dictionaries produced by ``analyze_transactions``.

    Returns:
        A dictionary with keys ``auto`` and ``manual`` containing the respective lists.
    """
    auto = [t for t in transactions if not t["is_fraud"]]
    manual = [t for t in transactions if t["is_fraud"]]

    logger.info("Routing %d auto‑approve and %d manual‑review transactions",
                len(auto), len(manual))
    return {"auto": auto, "manual": manual}


@task(retries=2, retry_delay_seconds=30, name="Route to Auto‑Approve")
def route_to_auto_approve(
    auto_transactions: List[Dict[str, Any]],
    payment_api_secret: Secret,
) -> None:
    """
    Send auto‑approved transactions to the payment processing system.

    This placeholder implementation logs the payload; replace with real API calls.

    Args:
        auto_transactions: List of transactions ready for auto‑approval.
        payment_api_secret: Secret block containing credentials for the payment API.
    """
    if not auto_transactions:
        logger.info("No auto‑approve transactions to process.")
        return

    credentials = payment_api_secret.get()
    logger.debug("Payment API credentials: %s", credentials)

    # Placeholder: simulate API call
    payload = {"transactions": auto_transactions}
    logger.info("Sending %d auto‑approved transactions to payment API",
                len(auto_transactions))
    logger.debug("Payload: %s", json.dumps(payload)[:200])


@task(retries=2, retry_delay_seconds=30, name="Route to Manual Review")
def route_to_manual_review(
    manual_transactions: List[Dict[str, Any]],
    manual_queue_secret: Secret,
) -> None:
    """
    Enqueue transactions that require manual review.

    This placeholder implementation logs the payload; replace with real queue logic.

    Args:
        manual_transactions: List of potentially fraudulent transactions.
        manual_queue_secret: Secret block containing connection details for the review queue.
    """
    if not manual_transactions:
        logger.info("No manual‑review transactions to enqueue.")
        return

    queue_info = manual_queue_secret.get()
    logger.debug("Manual review queue info: %s", queue_info)

    # Placeholder: simulate queue insertion
    payload = {"transactions": manual_transactions}
    logger.info("Enqueuing %d transactions for manual review", len(manual_transactions))
    logger.debug("Payload: %s", json.dumps(payload)[:200])


@task(retries=2, retry_delay_seconds=30, name="Send Notification")
def send_notification(
    auto_transactions: List[Dict[str, Any]],
    manual_transactions: List[Dict[str, Any]],
    notification_service_secret: Secret,
) -> None:
    """
    Notify downstream stakeholders about the routing outcome.

    Args:
        auto_transactions: List of auto‑approved transactions.
        manual_transactions: List of transactions sent for manual review.
        notification_service_secret: Secret block with credentials for the notification service.
    """
    notif_credentials = notification_service_secret.get()
    logger.debug("Notification service credentials: %s", notif_credentials)

    message = {
        "auto_approved": len(auto_transactions),
        "manual_review": len(manual_transactions),
    }

    # Placeholder: simulate sending a notification
    logger.info("Sending notification: %s", json.dumps(message))
    # In a real implementation, call the notification API here.


@flow(
    name="fraud_detection_triage",
    task_runner=ConcurrentTaskRunner(),
)
def fraud_detection_triage() -> None:
    """
    Main flow orchestrating the fraud detection triage pipeline.

    The flow:
    1. Loads configuration blocks.
    2. Analyzes the daily transaction CSV.
    3. Routes transactions to auto‑approve or manual review.
    4. Sends a notification summarising the results.
    """
    # Load infrastructure blocks
    csv_block: LocalFileSystem = LocalFileSystem.load("transaction_csv_files")
    manual_queue_secret: Secret = Secret.load("manual_review_queue")
    payment_api_secret: Secret = Secret.load("payment_processing_api")
    notification_service_secret: Secret = Secret.load("notification_service")

    # Resolve the path to today's CSV file.
    # Adjust this logic according to your naming convention.
    today_file = Path(csv_block.base_path) / "transactions_today.csv"
    csv_path = str(today_file)

    # Step 1: Analyze
    transactions = analyze_transactions(csv_path)

    # Step 2: Route
    routed = route_transaction(transactions)

    # Step 3: Parallel processing (fan‑out)
    auto_future = route_to_auto_approve.submit(
        routed["auto"], payment_api_secret=payment_api_secret
    )
    manual_future = route_to_manual_review.submit(
        routed["manual"], manual_queue_secret=manual_queue_secret
    )

    # Step 4: Fan‑in – wait for both routing branches before notifying
    send_notification(
        auto_transactions=routed["auto"],
        manual_transactions=routed["manual"],
        notification_service_secret=notification_service_secret,
    )


# -------------------------------------------------------------------------
# Deployment configuration
# -------------------------------------------------------------------------
DeploymentSpec(
    name="fraud_detection_triage_deployment",
    flow=fraud_detection_triage,
    schedule=CronSchedule(
        cron="0 0 * * *",  # @daily at midnight UTC
        timezone="UTC",
        catchup=False,
    ),
    tags=["fraud_detection"],
    work_pool_name="default-agent-pool",
    enforce_parameter_schema=False,
)